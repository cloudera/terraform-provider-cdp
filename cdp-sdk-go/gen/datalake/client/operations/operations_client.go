// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new operations API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for operations API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	BackupDatalake(params *BackupDatalakeParams, opts ...ClientOption) (*BackupDatalakeOK, error)

	BackupDatalakeStatus(params *BackupDatalakeStatusParams, opts ...ClientOption) (*BackupDatalakeStatusOK, error)

	CancelBackup(params *CancelBackupParams, opts ...ClientOption) (*CancelBackupOK, error)

	CancelDatalakeDiagnostics(params *CancelDatalakeDiagnosticsParams, opts ...ClientOption) (*CancelDatalakeDiagnosticsOK, error)

	CollectCmDiagnostics(params *CollectCmDiagnosticsParams, opts ...ClientOption) (*CollectCmDiagnosticsOK, error)

	CollectDatalakeDiagnostics(params *CollectDatalakeDiagnosticsParams, opts ...ClientOption) (*CollectDatalakeDiagnosticsOK, error)

	CreateAWSDatalake(params *CreateAWSDatalakeParams, opts ...ClientOption) (*CreateAWSDatalakeOK, error)

	CreateAWSGovCloudDatalake(params *CreateAWSGovCloudDatalakeParams, opts ...ClientOption) (*CreateAWSGovCloudDatalakeOK, error)

	CreateAzureDatalake(params *CreateAzureDatalakeParams, opts ...ClientOption) (*CreateAzureDatalakeOK, error)

	CreateGCPDatalake(params *CreateGCPDatalakeParams, opts ...ClientOption) (*CreateGCPDatalakeOK, error)

	DeleteDatalake(params *DeleteDatalakeParams, opts ...ClientOption) (*DeleteDatalakeOK, error)

	DescribeDatabaseServer(params *DescribeDatabaseServerParams, opts ...ClientOption) (*DescribeDatabaseServerOK, error)

	DescribeDatalake(params *DescribeDatalakeParams, opts ...ClientOption) (*DescribeDatalakeOK, error)

	EnableRangerRaz(params *EnableRangerRazParams, opts ...ClientOption) (*EnableRangerRazOK, error)

	GetClusterHostStatus(params *GetClusterHostStatusParams, opts ...ClientOption) (*GetClusterHostStatusOK, error)

	GetClusterServiceStatus(params *GetClusterServiceStatusParams, opts ...ClientOption) (*GetClusterServiceStatusOK, error)

	GetCmRoles(params *GetCmRolesParams, opts ...ClientOption) (*GetCmRolesOK, error)

	GetDatalakeLogDescriptors(params *GetDatalakeLogDescriptorsParams, opts ...ClientOption) (*GetDatalakeLogDescriptorsOK, error)

	ListDatalakeBackups(params *ListDatalakeBackupsParams, opts ...ClientOption) (*ListDatalakeBackupsOK, error)

	ListDatalakeDiagnostics(params *ListDatalakeDiagnosticsParams, opts ...ClientOption) (*ListDatalakeDiagnosticsOK, error)

	ListDatalakes(params *ListDatalakesParams, opts ...ClientOption) (*ListDatalakesOK, error)

	ListRuntimes(params *ListRuntimesParams, opts ...ClientOption) (*ListRuntimesOK, error)

	PrepareDatalakeUpgrade(params *PrepareDatalakeUpgradeParams, opts ...ClientOption) (*PrepareDatalakeUpgradeOK, error)

	RecoverDatalake(params *RecoverDatalakeParams, opts ...ClientOption) (*RecoverDatalakeOK, error)

	RenewCertificate(params *RenewCertificateParams, opts ...ClientOption) (*RenewCertificateOK, error)

	RenewPublicCertificate(params *RenewPublicCertificateParams, opts ...ClientOption) (*RenewPublicCertificateOK, error)

	RepairDatalake(params *RepairDatalakeParams, opts ...ClientOption) (*RepairDatalakeOK, error)

	ReplaceRecipes(params *ReplaceRecipesParams, opts ...ClientOption) (*ReplaceRecipesOK, error)

	ResizeDatalake(params *ResizeDatalakeParams, opts ...ClientOption) (*ResizeDatalakeOK, error)

	RestoreDatalake(params *RestoreDatalakeParams, opts ...ClientOption) (*RestoreDatalakeOK, error)

	RestoreDatalakeStatus(params *RestoreDatalakeStatusParams, opts ...ClientOption) (*RestoreDatalakeStatusOK, error)

	RetryDatalake(params *RetryDatalakeParams, opts ...ClientOption) (*RetryDatalakeOK, error)

	RotateAutoTLSCertificates(params *RotateAutoTLSCertificatesParams, opts ...ClientOption) (*RotateAutoTLSCertificatesOK, error)

	RotatePrivateCertificates(params *RotatePrivateCertificatesParams, opts ...ClientOption) (*RotatePrivateCertificatesOK, error)

	RotateSaltPassword(params *RotateSaltPasswordParams, opts ...ClientOption) (*RotateSaltPasswordOK, error)

	ScaleHorizontally(params *ScaleHorizontallyParams, opts ...ClientOption) (*ScaleHorizontallyOK, error)

	SetCatalog(params *SetCatalogParams, opts ...ClientOption) (*SetCatalogOK, error)

	StartDatabaseUpgrade(params *StartDatabaseUpgradeParams, opts ...ClientOption) (*StartDatabaseUpgradeOK, error)

	StartDatalake(params *StartDatalakeParams, opts ...ClientOption) (*StartDatalakeOK, error)

	StartDatalakeVerticalScaling(params *StartDatalakeVerticalScalingParams, opts ...ClientOption) (*StartDatalakeVerticalScalingOK, error)

	StopDatalake(params *StopDatalakeParams, opts ...ClientOption) (*StopDatalakeOK, error)

	SyncComponentVersionsFromCm(params *SyncComponentVersionsFromCmParams, opts ...ClientOption) (*SyncComponentVersionsFromCmOK, error)

	UpdateOrchestratorState(params *UpdateOrchestratorStateParams, opts ...ClientOption) (*UpdateOrchestratorStateOK, error)

	UpdateToAwsImdsV1(params *UpdateToAwsImdsV1Params, opts ...ClientOption) (*UpdateToAwsImdsV1OK, error)

	UpdateToAwsImdsV2(params *UpdateToAwsImdsV2Params, opts ...ClientOption) (*UpdateToAwsImdsV2OK, error)

	UpgradeDatalake(params *UpgradeDatalakeParams, opts ...ClientOption) (*UpgradeDatalakeOK, error)

	ValidateAwsCloudStorage(params *ValidateAwsCloudStorageParams, opts ...ClientOption) (*ValidateAwsCloudStorageOK, error)

	ValidateAzureCloudStorage(params *ValidateAzureCloudStorageParams, opts ...ClientOption) (*ValidateAzureCloudStorageOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
BackupDatalake creates backup of datalake

Takes a backup of all the data in the datalake.
*/
func (a *Client) BackupDatalake(params *BackupDatalakeParams, opts ...ClientOption) (*BackupDatalakeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBackupDatalakeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "backupDatalake",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/backupDatalake",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &BackupDatalakeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BackupDatalakeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*BackupDatalakeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
BackupDatalakeStatus checks the status of a datalake backup operation performed

Identifies the backup operation based on the inputs provided and gets the status. BackupName and BackupId are mutually exclusive. Only one of them can be provided.
*/
func (a *Client) BackupDatalakeStatus(params *BackupDatalakeStatusParams, opts ...ClientOption) (*BackupDatalakeStatusOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBackupDatalakeStatusParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "backupDatalakeStatus",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/backupDatalakeStatus",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &BackupDatalakeStatusReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BackupDatalakeStatusOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*BackupDatalakeStatusDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CancelBackup cancels the specified ongoing backup operation

Cancels a currently running backup operation. The operation must be in a STARTED or IN_PROGRESS state. Pending sub-operations will be ignored and marked as cancelled. The operation does not wait for the currently running sub-operation(s) to complete.
*/
func (a *Client) CancelBackup(params *CancelBackupParams, opts ...ClientOption) (*CancelBackupOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCancelBackupParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cancelBackup",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/cancelBackup",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CancelBackupReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CancelBackupOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CancelBackupDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CancelDatalakeDiagnostics cancels running datalake diagnostics collections

Cancel running Datalake diagnostics collection
*/
func (a *Client) CancelDatalakeDiagnostics(params *CancelDatalakeDiagnosticsParams, opts ...ClientOption) (*CancelDatalakeDiagnosticsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCancelDatalakeDiagnosticsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cancelDatalakeDiagnostics",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/cancelDatalakeDiagnostics",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CancelDatalakeDiagnosticsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CancelDatalakeDiagnosticsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CancelDatalakeDiagnosticsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CollectCmDiagnostics starts data lake cloudera manager based diagnostics collection

Start Datalake Cloudera Manager based diagnostics collection
*/
func (a *Client) CollectCmDiagnostics(params *CollectCmDiagnosticsParams, opts ...ClientOption) (*CollectCmDiagnosticsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCollectCmDiagnosticsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "collectCmDiagnostics",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/collectCmDiagnostics",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CollectCmDiagnosticsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CollectCmDiagnosticsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CollectCmDiagnosticsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CollectDatalakeDiagnostics starts data lake diagnostics collection

Start Datalake diagnostics collection
*/
func (a *Client) CollectDatalakeDiagnostics(params *CollectDatalakeDiagnosticsParams, opts ...ClientOption) (*CollectDatalakeDiagnosticsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCollectDatalakeDiagnosticsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "collectDatalakeDiagnostics",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/collectDatalakeDiagnostics",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CollectDatalakeDiagnosticsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CollectDatalakeDiagnosticsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CollectDatalakeDiagnosticsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateAWSDatalake creates an a w s datalake

Creates an AWS datalake.
*/
func (a *Client) CreateAWSDatalake(params *CreateAWSDatalakeParams, opts ...ClientOption) (*CreateAWSDatalakeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateAWSDatalakeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createAWSDatalake",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/createAWSDatalake",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateAWSDatalakeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateAWSDatalakeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateAWSDatalakeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateAWSGovCloudDatalake creates a data lake on a w s gov cloud

Creates a Data Lake on AWS GovCloud.
*/
func (a *Client) CreateAWSGovCloudDatalake(params *CreateAWSGovCloudDatalakeParams, opts ...ClientOption) (*CreateAWSGovCloudDatalakeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateAWSGovCloudDatalakeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createAWSGovCloudDatalake",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/createAWSGovCloudDatalake",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateAWSGovCloudDatalakeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateAWSGovCloudDatalakeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateAWSGovCloudDatalakeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateAzureDatalake creates an azure datalake

Creates an Azure datalake.
*/
func (a *Client) CreateAzureDatalake(params *CreateAzureDatalakeParams, opts ...ClientOption) (*CreateAzureDatalakeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateAzureDatalakeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createAzureDatalake",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/createAzureDatalake",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateAzureDatalakeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateAzureDatalakeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateAzureDatalakeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateGCPDatalake creates an g c p data lake

Creates an GCP Data Lake.
*/
func (a *Client) CreateGCPDatalake(params *CreateGCPDatalakeParams, opts ...ClientOption) (*CreateGCPDatalakeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateGCPDatalakeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createGCPDatalake",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/createGCPDatalake",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateGCPDatalakeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateGCPDatalakeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateGCPDatalakeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteDatalake deletes a datalake

Deletes a datalake.
*/
func (a *Client) DeleteDatalake(params *DeleteDatalakeParams, opts ...ClientOption) (*DeleteDatalakeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteDatalakeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteDatalake",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/deleteDatalake",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteDatalakeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteDatalakeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteDatalakeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DescribeDatabaseServer gets external database server details

Gets external database server details for Data Lake by cluster CRN
*/
func (a *Client) DescribeDatabaseServer(params *DescribeDatabaseServerParams, opts ...ClientOption) (*DescribeDatabaseServerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDescribeDatabaseServerParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "describeDatabaseServer",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/describeDatabaseServer",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DescribeDatabaseServerReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DescribeDatabaseServerOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DescribeDatabaseServerDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DescribeDatalake describes a datalake

Describes a datalake.
*/
func (a *Client) DescribeDatalake(params *DescribeDatalakeParams, opts ...ClientOption) (*DescribeDatalakeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDescribeDatalakeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "describeDatalake",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/describeDatalake",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DescribeDatalakeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DescribeDatalakeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DescribeDatalakeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
EnableRangerRaz sets the ranger raz enabled flag to true if raz is manually installed on the datalake

Sets the Ranger Raz enabled flag to true if Raz is manually installed on the datalake.
*/
func (a *Client) EnableRangerRaz(params *EnableRangerRazParams, opts ...ClientOption) (*EnableRangerRazOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEnableRangerRazParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "enableRangerRaz",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/enableRangerRaz",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &EnableRangerRazReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*EnableRangerRazOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*EnableRangerRazDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetClusterHostStatus gets cluster host status

Gets the status of the hosts in a cluster.
*/
func (a *Client) GetClusterHostStatus(params *GetClusterHostStatusParams, opts ...ClientOption) (*GetClusterHostStatusOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterHostStatusParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getClusterHostStatus",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/getClusterHostStatus",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterHostStatusReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterHostStatusOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterHostStatusDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetClusterServiceStatus gets cluster service status

Gets the status of the services in a cluster.
*/
func (a *Client) GetClusterServiceStatus(params *GetClusterServiceStatusParams, opts ...ClientOption) (*GetClusterServiceStatusOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterServiceStatusParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getClusterServiceStatus",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/getClusterServiceStatus",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterServiceStatusReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterServiceStatusOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterServiceStatusDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetCmRoles gathers cloudera manager roles that can be used for filtering in c m based diagnostics collection

Gather Cloudera Manager roles that can be used for filtering in CM based diagnostics collection.
*/
func (a *Client) GetCmRoles(params *GetCmRolesParams, opts ...ClientOption) (*GetCmRolesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCmRolesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getCmRoles",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/getCmRoles",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetCmRolesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetCmRolesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetCmRolesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetDatalakeLogDescriptors gathers log descriptors that are used for diagnostics collection

Gather log descriptors that are used for diagnostics collection.
*/
func (a *Client) GetDatalakeLogDescriptors(params *GetDatalakeLogDescriptorsParams, opts ...ClientOption) (*GetDatalakeLogDescriptorsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDatalakeLogDescriptorsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getDatalakeLogDescriptors",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/getDatalakeLogDescriptors",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetDatalakeLogDescriptorsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetDatalakeLogDescriptorsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetDatalakeLogDescriptorsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListDatalakeBackups lists all the backup operations that were performed on the datalake

List all the backup operations that were performed on the datalake.
*/
func (a *Client) ListDatalakeBackups(params *ListDatalakeBackupsParams, opts ...ClientOption) (*ListDatalakeBackupsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListDatalakeBackupsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listDatalakeBackups",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/listDatalakeBackups",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListDatalakeBackupsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListDatalakeBackupsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListDatalakeBackupsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListDatalakeDiagnostics lists recent datalake diagnostics collections

List recent Datalake diagnostics collection
*/
func (a *Client) ListDatalakeDiagnostics(params *ListDatalakeDiagnosticsParams, opts ...ClientOption) (*ListDatalakeDiagnosticsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListDatalakeDiagnosticsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listDatalakeDiagnostics",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/listDatalakeDiagnostics",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListDatalakeDiagnosticsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListDatalakeDiagnosticsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListDatalakeDiagnosticsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListDatalakes lists datalakes

Lists datalakes.
*/
func (a *Client) ListDatalakes(params *ListDatalakesParams, opts ...ClientOption) (*ListDatalakesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListDatalakesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listDatalakes",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/listDatalakes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListDatalakesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListDatalakesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListDatalakesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListRuntimes lists the datalake versions

Lists the available datalake runtime versions.
*/
func (a *Client) ListRuntimes(params *ListRuntimesParams, opts ...ClientOption) (*ListRuntimesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListRuntimesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listRuntimes",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/listRuntimes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListRuntimesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListRuntimesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListRuntimesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PrepareDatalakeUpgrade prepares the data lake cluster for upgrade

In order to reduce the chance of upgrade failures, we're introducing a preparation phase for runtime upgrades. During this phase, we're running all validations and downloading the required parcels for the machines. You can track the progress of the parcel preparation on the Cloudera Manager UI or you can check on the Management Console as well.
*/
func (a *Client) PrepareDatalakeUpgrade(params *PrepareDatalakeUpgradeParams, opts ...ClientOption) (*PrepareDatalakeUpgradeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPrepareDatalakeUpgradeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "prepareDatalakeUpgrade",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/prepareDatalakeUpgrade",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PrepareDatalakeUpgradeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PrepareDatalakeUpgradeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PrepareDatalakeUpgradeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
RecoverDatalake recovers data lake to the original version after a failed upgrade

Recover data lake to the original version after a failed upgrade.
*/
func (a *Client) RecoverDatalake(params *RecoverDatalakeParams, opts ...ClientOption) (*RecoverDatalakeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRecoverDatalakeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "recoverDatalake",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/recoverDatalake",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RecoverDatalakeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RecoverDatalakeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RecoverDatalakeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
RenewCertificate renews certificate on datalake cluster by name or c r n

Deprecated, please use renew-public-certificate command instead. Renew certificate on Datalake cluster by name or CRN.
*/
func (a *Client) RenewCertificate(params *RenewCertificateParams, opts ...ClientOption) (*RenewCertificateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRenewCertificateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "renewCertificate",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/renewCertificate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RenewCertificateReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RenewCertificateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RenewCertificateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
RenewPublicCertificate renews public certificate on datalake cluster by name or c r n

Renews public certificate on Datalake cluster by name or CRN.
*/
func (a *Client) RenewPublicCertificate(params *RenewPublicCertificateParams, opts ...ClientOption) (*RenewPublicCertificateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRenewPublicCertificateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "renewPublicCertificate",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/renewPublicCertificate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RenewPublicCertificateReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RenewPublicCertificateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RenewPublicCertificateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
RepairDatalake repairs a datalake

Repairs a datalake.
*/
func (a *Client) RepairDatalake(params *RepairDatalakeParams, opts ...ClientOption) (*RepairDatalakeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepairDatalakeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repairDatalake",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/repairDatalake",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RepairDatalakeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepairDatalakeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RepairDatalakeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ReplaceRecipes replaces recipes for the given instance groups

Replaces recipes for the given instance groups.
*/
func (a *Client) ReplaceRecipes(params *ReplaceRecipesParams, opts ...ClientOption) (*ReplaceRecipesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceRecipesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "replaceRecipes",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/replaceRecipes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ReplaceRecipesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplaceRecipesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplaceRecipesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ResizeDatalake resizes the given datalake to the given target size

Resizes the datalake to the given size.
*/
func (a *Client) ResizeDatalake(params *ResizeDatalakeParams, opts ...ClientOption) (*ResizeDatalakeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewResizeDatalakeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "resizeDatalake",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/resizeDatalake",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ResizeDatalakeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ResizeDatalakeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ResizeDatalakeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
RestoreDatalake restores the datalake from backup taken

Restore the datalake from a backup that was taken. Backup to be used for restore is identified based on the information provided in the restore request. BackupId and BackupName are mutually exclusive. Only one of them can be provided. If both are provided, BackupId takes precedence.
*/
func (a *Client) RestoreDatalake(params *RestoreDatalakeParams, opts ...ClientOption) (*RestoreDatalakeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRestoreDatalakeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "restoreDatalake",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/restoreDatalake",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RestoreDatalakeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RestoreDatalakeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RestoreDatalakeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
RestoreDatalakeStatus checks the status of datalake restore operation

Identifies the restore operation based on the inputs provided and gets the status. RestoreId and BackupName are mutually exclusive. Only one of them can be provided.
*/
func (a *Client) RestoreDatalakeStatus(params *RestoreDatalakeStatusParams, opts ...ClientOption) (*RestoreDatalakeStatusOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRestoreDatalakeStatusParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "restoreDatalakeStatus",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/restoreDatalakeStatus",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RestoreDatalakeStatusReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RestoreDatalakeStatusOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RestoreDatalakeStatusDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
RetryDatalake retries last failed operation on a datalake

Retry last failed operation on a datalake.
*/
func (a *Client) RetryDatalake(params *RetryDatalakeParams, opts ...ClientOption) (*RetryDatalakeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRetryDatalakeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "retryDatalake",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/retryDatalake",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RetryDatalakeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RetryDatalakeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RetryDatalakeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
RotateAutoTLSCertificates rotates autotls certificates on the datalake s hosts

Deprecated, please use rotate-private-certificates command instead. Rotate autotls certificates on the datalake's hosts
*/
func (a *Client) RotateAutoTLSCertificates(params *RotateAutoTLSCertificatesParams, opts ...ClientOption) (*RotateAutoTLSCertificatesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRotateAutoTLSCertificatesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "rotateAutoTlsCertificates",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/rotateAutoTlsCertificates",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RotateAutoTLSCertificatesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RotateAutoTLSCertificatesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RotateAutoTLSCertificatesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
RotatePrivateCertificates rotates private certificates on the datalake s hosts

Rotates private certificates on the datalake's hosts.
*/
func (a *Client) RotatePrivateCertificates(params *RotatePrivateCertificatesParams, opts ...ClientOption) (*RotatePrivateCertificatesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRotatePrivateCertificatesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "rotatePrivateCertificates",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/rotatePrivateCertificates",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RotatePrivateCertificatesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RotatePrivateCertificatesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RotatePrivateCertificatesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
RotateSaltPassword rotates salt stack user password on data lake instances

Rotate SaltStack user password on DataLake instances.
*/
func (a *Client) RotateSaltPassword(params *RotateSaltPasswordParams, opts ...ClientOption) (*RotateSaltPasswordOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRotateSaltPasswordParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "rotateSaltPassword",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/rotateSaltPassword",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RotateSaltPasswordReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RotateSaltPasswordOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RotateSaltPasswordDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ScaleHorizontally horizontallies scale the data lake nodes to add additional compute nodes to the cluster

Horizontally scale the target host group in the Data Lake cluster. The possible option for the instance group are raz_scale_out, hms_scale_out, kafka_scale_out, solr_scale_out, storage_scale_out
*/
func (a *Client) ScaleHorizontally(params *ScaleHorizontallyParams, opts ...ClientOption) (*ScaleHorizontallyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewScaleHorizontallyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "scaleHorizontally",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/scaleHorizontally",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ScaleHorizontallyReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ScaleHorizontallyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ScaleHorizontallyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
SetCatalog sets a catalog for a data lake

Sets a catalog for a DataLake.
*/
func (a *Client) SetCatalog(params *SetCatalogParams, opts ...ClientOption) (*SetCatalogOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSetCatalogParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "setCatalog",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/setCatalog",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SetCatalogReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SetCatalogOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SetCatalogDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
StartDatabaseUpgrade upgrades the database of the data lake cluster

This command initiates the upgrade of the database of the Data Lake cluster.
*/
func (a *Client) StartDatabaseUpgrade(params *StartDatabaseUpgradeParams, opts ...ClientOption) (*StartDatabaseUpgradeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewStartDatabaseUpgradeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "startDatabaseUpgrade",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/startDatabaseUpgrade",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StartDatabaseUpgradeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*StartDatabaseUpgradeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*StartDatabaseUpgradeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
StartDatalake starts datalake

Deprecated, please use 'cdp environments start-environment' instead.
*/
func (a *Client) StartDatalake(params *StartDatalakeParams, opts ...ClientOption) (*StartDatalakeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewStartDatalakeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "startDatalake",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/startDatalake",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StartDatalakeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*StartDatalakeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*StartDatalakeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
StartDatalakeVerticalScaling initiates the vertical scaling on data lake

Initiates the vertical scaling on Data Lake. You have the option to specify 'modifyDisks' or 'instanceTemplate' as parameter.
*/
func (a *Client) StartDatalakeVerticalScaling(params *StartDatalakeVerticalScalingParams, opts ...ClientOption) (*StartDatalakeVerticalScalingOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewStartDatalakeVerticalScalingParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "startDatalakeVerticalScaling",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/startDatalakeVerticalScaling",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StartDatalakeVerticalScalingReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*StartDatalakeVerticalScalingOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*StartDatalakeVerticalScalingDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
StopDatalake stops datalake

Deprecated, please use 'cdp environments stop-environment' instead.
*/
func (a *Client) StopDatalake(params *StopDatalakeParams, opts ...ClientOption) (*StopDatalakeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewStopDatalakeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "stopDatalake",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/stopDatalake",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StopDatalakeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*StopDatalakeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*StopDatalakeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
SyncComponentVersionsFromCm syncs component versions from c m after a failed upgrade

Syncs component versions from CM after a failed upgrade.
*/
func (a *Client) SyncComponentVersionsFromCm(params *SyncComponentVersionsFromCmParams, opts ...ClientOption) (*SyncComponentVersionsFromCmOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSyncComponentVersionsFromCmParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "syncComponentVersionsFromCm",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/syncComponentVersionsFromCm",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SyncComponentVersionsFromCmReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SyncComponentVersionsFromCmOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SyncComponentVersionsFromCmDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateOrchestratorState runs orchestrator engine state update on the data lake cluster

Run orchestrator engine state update on the Data Lake cluster.
*/
func (a *Client) UpdateOrchestratorState(params *UpdateOrchestratorStateParams, opts ...ClientOption) (*UpdateOrchestratorStateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateOrchestratorStateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateOrchestratorState",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/updateOrchestratorState",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateOrchestratorStateReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateOrchestratorStateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateOrchestratorStateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateToAwsImdsV1 updates data lake a w s cluster to use i m d sv1

Updates Data Lake AWS cluster to use IMDSv1.
*/
func (a *Client) UpdateToAwsImdsV1(params *UpdateToAwsImdsV1Params, opts ...ClientOption) (*UpdateToAwsImdsV1OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateToAwsImdsV1Params()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateToAwsImdsV1",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/updateToAwsImdsV1",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateToAwsImdsV1Reader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateToAwsImdsV1OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateToAwsImdsV1Default)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateToAwsImdsV2 updates data lake a w s cluster to use i m d sv2

Updates Data Lake AWS cluster to use IMDSv2.
*/
func (a *Client) UpdateToAwsImdsV2(params *UpdateToAwsImdsV2Params, opts ...ClientOption) (*UpdateToAwsImdsV2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateToAwsImdsV2Params()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateToAwsImdsV2",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/updateToAwsImdsV2",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateToAwsImdsV2Reader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateToAwsImdsV2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateToAwsImdsV2Default)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpgradeDatalake os s or data platform upgrade for the s d x cluster

OS or data platform upgrade for the SDX cluster. You have the option to either specify one of 'imageId', 'runtime' or 'lockComponents' or both 'imageId' and 'lockComponents' or none of the parameters.
*/
func (a *Client) UpgradeDatalake(params *UpgradeDatalakeParams, opts ...ClientOption) (*UpgradeDatalakeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpgradeDatalakeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "upgradeDatalake",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/upgradeDatalake",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpgradeDatalakeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpgradeDatalakeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpgradeDatalakeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ValidateAwsCloudStorage validates a w s cloud storage

Validates AWS cloud storage for Data Lake.
*/
func (a *Client) ValidateAwsCloudStorage(params *ValidateAwsCloudStorageParams, opts ...ClientOption) (*ValidateAwsCloudStorageOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewValidateAwsCloudStorageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "validateAwsCloudStorage",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/validateAwsCloudStorage",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ValidateAwsCloudStorageReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ValidateAwsCloudStorageOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ValidateAwsCloudStorageDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ValidateAzureCloudStorage validates azure cloud storage

Validates Azure cloud storage for Data Lake.
*/
func (a *Client) ValidateAzureCloudStorage(params *ValidateAzureCloudStorageParams, opts ...ClientOption) (*ValidateAzureCloudStorageOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewValidateAzureCloudStorageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "validateAzureCloudStorage",
		Method:             "POST",
		PathPattern:        "/api/v1/datalake/validateAzureCloudStorage",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ValidateAzureCloudStorageReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ValidateAzureCloudStorageOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ValidateAzureCloudStorageDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
