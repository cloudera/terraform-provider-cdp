// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CreateAwsClusterRequest Request object for the createAwsCluster method.
//
// swagger:model CreateAwsClusterRequest
type CreateAwsClusterRequest struct {

	// Additional (fallback) instance types listed in their priority order. They will be used instead of the primary compute instance type in case it is unavailable. You cannot include any instance type that was already indicated in computeInstanceTypes. Use describe-allowed-instance-types to see currently supported values and also the default value when nothing is provided for the computeInstanceTypes.
	AdditionalInstanceTypes []string `json:"additionalInstanceTypes"`

	// AWS compute instance types that the environment is restricted to use. This affects the creation of virtual warehouses where this restriction will apply. Select an instance type that meets your computing, memory, networking, or storage needs. As of now, only a single instance type can be listed. Use describe-allowed-instance-types to see currently possible values.
	ComputeInstanceTypes []string `json:"computeInstanceTypes"`

	// Custom AMI ID.
	CustomAmiID string `json:"customAmiId,omitempty"`

	// Options for custom ACR/ECR/Docker registries.
	CustomRegistryOptions *CustomRegistryOptions `json:"customRegistryOptions,omitempty"`

	// Custom environment subdomain. Overrides the environment subdomain using a customized domain either in the old subdomain format like ENV_ID.dw or the new format like dw-ENV_NAME.
	CustomSubdomain string `json:"customSubdomain,omitempty"`

	// PostgreSQL server backup retention days.
	DatabaseBackupRetentionPeriod *int32 `json:"databaseBackupRetentionPeriod,omitempty"`

	// Use this option to set up AWS EKS cluster in private only mode with restricted access only from internal/peered networks. Ensure you have ccmv2 setup functional to achieve this integration.
	EnablePrivateEKS *bool `json:"enablePrivateEKS,omitempty"`

	// Whether to enable Spot instances for Virtual warehouses. It cannot be updated later. Defaults to false.
	EnableSpotInstances *bool `json:"enableSpotInstances,omitempty"`

	// The CRN of the environment for the cluster to create.
	// Required: true
	EnvironmentCrn *string `json:"environmentCrn"`

	// IDs of AWS subnets where the cluster load balancer should be deployed.
	LbSubnetIds []string `json:"lbSubnetIds"`

	// Managed Policy Arn to be attached to the Node Instance Role.
	NodeRoleCDWManagedPolicyArn string `json:"nodeRoleCDWManagedPolicyArn,omitempty"`

	// Use this option to activate the environment with fewer than half of the standard required IAM permissions on your AWS cross-account IAM role.
	ReducedPermissionMode bool `json:"reducedPermissionMode,omitempty"`

	// Set additional number of nodes to reserve for executors and coordinators to use during autoscaling. Adding more reserved nodes increases your cloud costs.
	ReservedComputeNodes int32 `json:"reservedComputeNodes,omitempty"`

	// Set additional number of nodes to reserve for other services in the cluster. Adding more reserved nodes increases your cloud costs.
	ReservedSharedServicesNodes int32 `json:"reservedSharedServicesNodes,omitempty"`

	// Using an overlay network will save IP addresses in the VPC by using a private IP address range for Pods in the cluster.
	UseOverlayNetwork bool `json:"useOverlayNetwork,omitempty"`

	// Set up load balancer with private IP address. In AWS it is created in private subnets. In Azure an internal load balancer gets created. Make sure there is connectivity between your client network and the network (VPC/VNet) where CDW environment is deployed.
	UsePrivateLoadBalancer bool `json:"usePrivateLoadBalancer,omitempty"`

	// Set up worker node with public IP address. In AWS it is created in public subnets.
	UsePublicWorkerNode bool `json:"usePublicWorkerNode,omitempty"`

	// List of IP address CIDRs to whitelist for kubernetes cluster access.
	WhitelistK8sClusterAccessIPCIDRs []string `json:"whitelistK8sClusterAccessIpCIDRs"`

	// List of IP address CIDRs to whitelist for workload access.
	WhitelistWorkloadAccessIPCIDRs []string `json:"whitelistWorkloadAccessIpCIDRs"`

	// IDs of AWS subnets where the cluster worker nodes should be deployed.
	WorkerSubnetIds []string `json:"workerSubnetIds"`
}

// Validate validates this create aws cluster request
func (m *CreateAwsClusterRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCustomRegistryOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnvironmentCrn(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CreateAwsClusterRequest) validateCustomRegistryOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.CustomRegistryOptions) { // not required
		return nil
	}

	if m.CustomRegistryOptions != nil {
		if err := m.CustomRegistryOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("customRegistryOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("customRegistryOptions")
			}
			return err
		}
	}

	return nil
}

func (m *CreateAwsClusterRequest) validateEnvironmentCrn(formats strfmt.Registry) error {

	if err := validate.Required("environmentCrn", "body", m.EnvironmentCrn); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create aws cluster request based on the context it is used
func (m *CreateAwsClusterRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCustomRegistryOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CreateAwsClusterRequest) contextValidateCustomRegistryOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.CustomRegistryOptions != nil {

		if swag.IsZero(m.CustomRegistryOptions) { // not required
			return nil
		}

		if err := m.CustomRegistryOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("customRegistryOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("customRegistryOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CreateAwsClusterRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CreateAwsClusterRequest) UnmarshalBinary(b []byte) error {
	var res CreateAwsClusterRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
