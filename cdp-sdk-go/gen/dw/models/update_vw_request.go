// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	stderrors "errors"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// UpdateVwRequest Request object for the updateVw method.
//
// swagger:model UpdateVwRequest
type UpdateVwRequest struct {

	// Autoscaling settings for the Virtual Warehouse.
	Autoscaling *AutoscalingOptionsUpdateRequest `json:"autoscaling,omitempty"`

	// ID of the Virtual Warehouse's cluster.
	// Required: true
	ClusterID *string `json:"clusterId"`

	// The service configuration to update the VW with. This will be applied on top of the existing configuration so there's no need to list configurations that stay the same.
	Config *ServiceConfigReq `json:"config,omitempty"`

	// DEPRECATED - Sets the authentication mode to use by Hive Server: * `LDAP` * `KERBEROS` If not set then the authentication mode will not be changed during update.
	HiveAuthenticationMode *string `json:"hiveAuthenticationMode,omitempty"`

	// If specified, modifies Hive Server High Availability mode in Private Cloud: * `DISABLED` - Disables Hive Server high availability. * `ACTIVE_PASSIVE` - Runs two Hive Server instances, one active and one passive. Hive session failover is not supported in this setup.
	HiveServerHaMode *string `json:"hiveServerHaMode,omitempty"`

	// High Availability settings update for the Impala Virtual Warehouse.
	ImpalaHaSettings *ImpalaHASettingsUpdateRequest `json:"impalaHaSettings,omitempty"`

	// Denotes whether the Virtual Warehouse has the Impala Query Log enabled or not.
	ImpalaQueryLog *bool `json:"impalaQueryLog,omitempty"`

	// Denotes whether the Hive Virtual Warehouse stores Hive query information for all completed queries in the sys.query_history system table. You can query this table using SQL to monitor and optimize the Hive engine.
	LogHiveQueries *bool `json:"logHiveQueries,omitempty"`

	// Nodes per compute cluster. If specified, forces 'template' to be 'custom'
	NodeCount int32 `json:"nodeCount,omitempty"`

	// Value of 'true' automatically configures the Virtual Warehouse to support JWTs issues by the CDP JWT token provider.  Value of 'false' does not enable JWT auth on the Virtual Warehouse.  If this field is not specified, it defaults to 'false'.
	PlatformJwtAuth *bool `json:"platformJwtAuth,omitempty"`

	// Query isolation settings for Hive Virtual Warehouses.
	QueryIsolationOptions *QueryIsolationOptionsRequest `json:"queryIsolationOptions,omitempty"`

	// DEPRECATED: This functionality will be removed in the next release. Used to set the resource pool of the Virtual Warehouses that are not enrolled for quota management.
	ResourcePool string `json:"resourcePool,omitempty"`

	// Name of T-shirt size to use, which will determine the number of nodes.
	// Enum: ["xsmall","small","medium","large"]
	TShirtSize string `json:"tShirtSize,omitempty"`

	// ID of the Virtual Warehouse.
	// Required: true
	VwID *string `json:"vwId"`
}

// Validate validates this update vw request
func (m *UpdateVwRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAutoscaling(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImpalaHaSettings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQueryIsolationOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTShirtSize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVwID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UpdateVwRequest) validateAutoscaling(formats strfmt.Registry) error {
	if swag.IsZero(m.Autoscaling) { // not required
		return nil
	}

	if m.Autoscaling != nil {
		if err := m.Autoscaling.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("autoscaling")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("autoscaling")
			}

			return err
		}
	}

	return nil
}

func (m *UpdateVwRequest) validateClusterID(formats strfmt.Registry) error {

	if err := validate.Required("clusterId", "body", m.ClusterID); err != nil {
		return err
	}

	return nil
}

func (m *UpdateVwRequest) validateConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.Config) { // not required
		return nil
	}

	if m.Config != nil {
		if err := m.Config.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("config")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("config")
			}

			return err
		}
	}

	return nil
}

func (m *UpdateVwRequest) validateImpalaHaSettings(formats strfmt.Registry) error {
	if swag.IsZero(m.ImpalaHaSettings) { // not required
		return nil
	}

	if m.ImpalaHaSettings != nil {
		if err := m.ImpalaHaSettings.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("impalaHaSettings")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("impalaHaSettings")
			}

			return err
		}
	}

	return nil
}

func (m *UpdateVwRequest) validateQueryIsolationOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.QueryIsolationOptions) { // not required
		return nil
	}

	if m.QueryIsolationOptions != nil {
		if err := m.QueryIsolationOptions.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("queryIsolationOptions")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("queryIsolationOptions")
			}

			return err
		}
	}

	return nil
}

var updateVwRequestTypeTShirtSizePropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["xsmall","small","medium","large"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		updateVwRequestTypeTShirtSizePropEnum = append(updateVwRequestTypeTShirtSizePropEnum, v)
	}
}

const (

	// UpdateVwRequestTShirtSizeXsmall captures enum value "xsmall"
	UpdateVwRequestTShirtSizeXsmall string = "xsmall"

	// UpdateVwRequestTShirtSizeSmall captures enum value "small"
	UpdateVwRequestTShirtSizeSmall string = "small"

	// UpdateVwRequestTShirtSizeMedium captures enum value "medium"
	UpdateVwRequestTShirtSizeMedium string = "medium"

	// UpdateVwRequestTShirtSizeLarge captures enum value "large"
	UpdateVwRequestTShirtSizeLarge string = "large"
)

// prop value enum
func (m *UpdateVwRequest) validateTShirtSizeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, updateVwRequestTypeTShirtSizePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *UpdateVwRequest) validateTShirtSize(formats strfmt.Registry) error {
	if swag.IsZero(m.TShirtSize) { // not required
		return nil
	}

	// value enum
	if err := m.validateTShirtSizeEnum("tShirtSize", "body", m.TShirtSize); err != nil {
		return err
	}

	return nil
}

func (m *UpdateVwRequest) validateVwID(formats strfmt.Registry) error {

	if err := validate.Required("vwId", "body", m.VwID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this update vw request based on the context it is used
func (m *UpdateVwRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAutoscaling(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateImpalaHaSettings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQueryIsolationOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UpdateVwRequest) contextValidateAutoscaling(ctx context.Context, formats strfmt.Registry) error {

	if m.Autoscaling != nil {

		if swag.IsZero(m.Autoscaling) { // not required
			return nil
		}

		if err := m.Autoscaling.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("autoscaling")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("autoscaling")
			}

			return err
		}
	}

	return nil
}

func (m *UpdateVwRequest) contextValidateConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.Config != nil {

		if swag.IsZero(m.Config) { // not required
			return nil
		}

		if err := m.Config.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("config")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("config")
			}

			return err
		}
	}

	return nil
}

func (m *UpdateVwRequest) contextValidateImpalaHaSettings(ctx context.Context, formats strfmt.Registry) error {

	if m.ImpalaHaSettings != nil {

		if swag.IsZero(m.ImpalaHaSettings) { // not required
			return nil
		}

		if err := m.ImpalaHaSettings.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("impalaHaSettings")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("impalaHaSettings")
			}

			return err
		}
	}

	return nil
}

func (m *UpdateVwRequest) contextValidateQueryIsolationOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.QueryIsolationOptions != nil {

		if swag.IsZero(m.QueryIsolationOptions) { // not required
			return nil
		}

		if err := m.QueryIsolationOptions.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("queryIsolationOptions")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("queryIsolationOptions")
			}

			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *UpdateVwRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *UpdateVwRequest) UnmarshalBinary(b []byte) error {
	var res UpdateVwRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
