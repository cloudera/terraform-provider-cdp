// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// VwSummary A Virtual Warehouse.
//
// swagger:model VwSummary
type VwSummary struct {

	// The current settings stored for autoscaling.
	AutoscalingOptions *AutoscalingOptionsResponse `json:"autoscalingOptions,omitempty"`

	// Availability zone in which the Virtual Warehouse is running.
	AvailabilityZone string `json:"availabilityZone,omitempty"`

	// CDH image version.
	CdhVersion string `json:"cdhVersion,omitempty"`

	// Denotes whether the Hive Virtual Warehouse is a compactor or not.
	Compactor bool `json:"compactor,omitempty"`

	// ID of the configuration.
	ConfigID string `json:"configId,omitempty"`

	// Creation date of Virtual Warehouse.
	// Format: date-time
	CreationDate strfmt.DateTime `json:"creationDate,omitempty"`

	// The creator of the Virtual Warehouse.
	Creator *ActorResponse `json:"creator,omitempty"`

	// The CRN of the Virtual Warehouse.
	Crn string `json:"crn,omitempty"`

	// ID of Database Catalog that the Virtual Warehouse is attached to.
	DbcID string `json:"dbcId,omitempty"`

	// Provides EBS gp3 volume as temporary storage space for Hive LLAP cache, and improves query performance. Configurable only at Virtual Warehouse creation. Using EBS volumes incurs additional costs.
	EbsLLAPSpillGB int32 `json:"ebsLLAPSpillGB,omitempty"`

	// Denotes whether the Unified Analytics is enabled.
	EnableUnifiedAnalytics bool `json:"enableUnifiedAnalytics,omitempty"`

	// endpoints
	Endpoints *VwSummaryEndpoints `json:"endpoints,omitempty"`

	// DEPRECATED - Authentication mode used by Hive Server: * `LDAP` * `KERBEROS`
	HiveAuthenticationMode *string `json:"hiveAuthenticationMode,omitempty"`

	// Hive Server High Availability mode in Private Cloud: * `DISABLED` - Hive Server high availability is disabled. * `ACTIVE_PASSIVE` - Hive Server high availability is enabled with one active and one passive instances. Hive session failover is not supported in this setup.
	HiveServerHaMode *string `json:"hiveServerHaMode,omitempty"`

	// The ID of the Virtual Warehouse.
	ID string `json:"id,omitempty"`

	// Current Impala High Availability settings.
	ImpalaHaSettingsOptions *ImpalaHASettingsOptionsResponse `json:"impalaHaSettingsOptions,omitempty"`

	// Current Impala settings.
	ImpalaOptions *ImpalaOptionsResponse `json:"impalaOptions,omitempty"`

	// Denotes whether the Virtual Warehouse has the Impala Query Log enabled or not.
	ImpalaQueryLog bool `json:"impalaQueryLog,omitempty"`

	// The underlying instance type for this Virtual Warehouse.
	InstanceType string `json:"instanceType,omitempty"`

	// jwt auth
	JwtAuth *VwSummaryJwtAuth `json:"jwtAuth,omitempty"`

	// Memory size of the Virtual Warehouse in MB.
	MemoryCapacity int32 `json:"memoryCapacity,omitempty"`

	// The name of the Virtual Warehouse.
	Name string `json:"name,omitempty"`

	// Size of the Virtual Warehouse (node count per compute cluster).
	NodeCount int32 `json:"nodeCount,omitempty"`

	// Number of cores of the Virtual Warehouse.
	NumOfCores int32 `json:"numOfCores,omitempty"`

	// The current settings stored for query-isolation.
	QueryIsolationOptions *QueryIsolationOptionsResponse `json:"queryIsolationOptions,omitempty"`

	// Status information on the current state of replicas in the virtual warehouse.
	ReplicaStatus *ReplicaStatus `json:"replicaStatus,omitempty"`

	// The name of the Resource Pool the Virtual Warehouse is in.
	ResourcePool string `json:"resourcePool,omitempty"`

	// The actual resources used by the Virtual Warehouse.
	Resources map[string]ApplicationResources `json:"resources,omitempty"`

	// Status of the Virtual Warehouse. Possible values are: Creating, Created, Accepted, Starting, Running, Stopping, Stopped, Updating, PreUpdate, Upgrading, PreUpgrade, Restarting, Deleting, Waiting, Failed, Error.
	Status string `json:"status,omitempty"`

	// Timestamp of the last status change of the Virtual Warehouse.
	// Format: date-time
	StatusChangedAt strfmt.DateTime `json:"statusChangedAt,omitempty"`

	// supported auth methods
	SupportedAuthMethods *VwSummarySupportedAuthMethods `json:"supportedAuthMethods,omitempty"`

	// Tags associated with the resources.
	Tags []*TagResponse `json:"tags"`

	// Denotes whether the Virtual Warehouse has Data Visualisation or not.
	Viz bool `json:"viz,omitempty"`

	// The type of the Virtual Warehouse.
	VwType VwType `json:"vwType,omitempty"`
}

// Validate validates this vw summary
func (m *VwSummary) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAutoscalingOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreationDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEndpoints(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImpalaHaSettingsOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImpalaOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJwtAuth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQueryIsolationOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReplicaStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResources(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatusChangedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSupportedAuthMethods(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTags(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVwType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VwSummary) validateAutoscalingOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.AutoscalingOptions) { // not required
		return nil
	}

	if m.AutoscalingOptions != nil {
		if err := m.AutoscalingOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("autoscalingOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("autoscalingOptions")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) validateCreationDate(formats strfmt.Registry) error {
	if swag.IsZero(m.CreationDate) { // not required
		return nil
	}

	if err := validate.FormatOf("creationDate", "body", "date-time", m.CreationDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *VwSummary) validateCreator(formats strfmt.Registry) error {
	if swag.IsZero(m.Creator) { // not required
		return nil
	}

	if m.Creator != nil {
		if err := m.Creator.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("creator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("creator")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) validateEndpoints(formats strfmt.Registry) error {
	if swag.IsZero(m.Endpoints) { // not required
		return nil
	}

	if m.Endpoints != nil {
		if err := m.Endpoints.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("endpoints")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("endpoints")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) validateImpalaHaSettingsOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.ImpalaHaSettingsOptions) { // not required
		return nil
	}

	if m.ImpalaHaSettingsOptions != nil {
		if err := m.ImpalaHaSettingsOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("impalaHaSettingsOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("impalaHaSettingsOptions")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) validateImpalaOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.ImpalaOptions) { // not required
		return nil
	}

	if m.ImpalaOptions != nil {
		if err := m.ImpalaOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("impalaOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("impalaOptions")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) validateJwtAuth(formats strfmt.Registry) error {
	if swag.IsZero(m.JwtAuth) { // not required
		return nil
	}

	if m.JwtAuth != nil {
		if err := m.JwtAuth.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("jwtAuth")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("jwtAuth")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) validateQueryIsolationOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.QueryIsolationOptions) { // not required
		return nil
	}

	if m.QueryIsolationOptions != nil {
		if err := m.QueryIsolationOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("queryIsolationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("queryIsolationOptions")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) validateReplicaStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.ReplicaStatus) { // not required
		return nil
	}

	if m.ReplicaStatus != nil {
		if err := m.ReplicaStatus.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("replicaStatus")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("replicaStatus")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) validateResources(formats strfmt.Registry) error {
	if swag.IsZero(m.Resources) { // not required
		return nil
	}

	for k := range m.Resources {

		if err := validate.Required("resources"+"."+k, "body", m.Resources[k]); err != nil {
			return err
		}
		if val, ok := m.Resources[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("resources" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("resources" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *VwSummary) validateStatusChangedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.StatusChangedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("statusChangedAt", "body", "date-time", m.StatusChangedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *VwSummary) validateSupportedAuthMethods(formats strfmt.Registry) error {
	if swag.IsZero(m.SupportedAuthMethods) { // not required
		return nil
	}

	if m.SupportedAuthMethods != nil {
		if err := m.SupportedAuthMethods.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("supportedAuthMethods")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("supportedAuthMethods")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) validateTags(formats strfmt.Registry) error {
	if swag.IsZero(m.Tags) { // not required
		return nil
	}

	for i := 0; i < len(m.Tags); i++ {
		if swag.IsZero(m.Tags[i]) { // not required
			continue
		}

		if m.Tags[i] != nil {
			if err := m.Tags[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tags" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tags" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VwSummary) validateVwType(formats strfmt.Registry) error {
	if swag.IsZero(m.VwType) { // not required
		return nil
	}

	if err := m.VwType.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("vwType")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("vwType")
		}
		return err
	}

	return nil
}

// ContextValidate validate this vw summary based on the context it is used
func (m *VwSummary) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAutoscalingOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEndpoints(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateImpalaHaSettingsOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateImpalaOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJwtAuth(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQueryIsolationOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReplicaStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateResources(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSupportedAuthMethods(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTags(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVwType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VwSummary) contextValidateAutoscalingOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.AutoscalingOptions != nil {

		if swag.IsZero(m.AutoscalingOptions) { // not required
			return nil
		}

		if err := m.AutoscalingOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("autoscalingOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("autoscalingOptions")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) contextValidateCreator(ctx context.Context, formats strfmt.Registry) error {

	if m.Creator != nil {

		if swag.IsZero(m.Creator) { // not required
			return nil
		}

		if err := m.Creator.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("creator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("creator")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) contextValidateEndpoints(ctx context.Context, formats strfmt.Registry) error {

	if m.Endpoints != nil {

		if swag.IsZero(m.Endpoints) { // not required
			return nil
		}

		if err := m.Endpoints.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("endpoints")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("endpoints")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) contextValidateImpalaHaSettingsOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.ImpalaHaSettingsOptions != nil {

		if swag.IsZero(m.ImpalaHaSettingsOptions) { // not required
			return nil
		}

		if err := m.ImpalaHaSettingsOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("impalaHaSettingsOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("impalaHaSettingsOptions")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) contextValidateImpalaOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.ImpalaOptions != nil {

		if swag.IsZero(m.ImpalaOptions) { // not required
			return nil
		}

		if err := m.ImpalaOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("impalaOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("impalaOptions")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) contextValidateJwtAuth(ctx context.Context, formats strfmt.Registry) error {

	if m.JwtAuth != nil {

		if swag.IsZero(m.JwtAuth) { // not required
			return nil
		}

		if err := m.JwtAuth.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("jwtAuth")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("jwtAuth")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) contextValidateQueryIsolationOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.QueryIsolationOptions != nil {

		if swag.IsZero(m.QueryIsolationOptions) { // not required
			return nil
		}

		if err := m.QueryIsolationOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("queryIsolationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("queryIsolationOptions")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) contextValidateReplicaStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.ReplicaStatus != nil {

		if swag.IsZero(m.ReplicaStatus) { // not required
			return nil
		}

		if err := m.ReplicaStatus.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("replicaStatus")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("replicaStatus")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) contextValidateResources(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.Resources {

		if val, ok := m.Resources[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *VwSummary) contextValidateSupportedAuthMethods(ctx context.Context, formats strfmt.Registry) error {

	if m.SupportedAuthMethods != nil {

		if swag.IsZero(m.SupportedAuthMethods) { // not required
			return nil
		}

		if err := m.SupportedAuthMethods.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("supportedAuthMethods")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("supportedAuthMethods")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) contextValidateTags(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Tags); i++ {

		if m.Tags[i] != nil {

			if swag.IsZero(m.Tags[i]) { // not required
				return nil
			}

			if err := m.Tags[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tags" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tags" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VwSummary) contextValidateVwType(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.VwType) { // not required
		return nil
	}

	if err := m.VwType.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("vwType")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("vwType")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VwSummary) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VwSummary) UnmarshalBinary(b []byte) error {
	var res VwSummary
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VwSummaryEndpoints Endpoints for accessing the Virtual Warehouse.
//
// swagger:model VwSummaryEndpoints
type VwSummaryEndpoints struct {

	// URL of Data Analytics Studio for Hive Virtual Warehouses.
	Das string `json:"das,omitempty"`

	// Command to use impala-shell for Unified Analytics
	FengImpalaShell string `json:"fengImpalaShell,omitempty"`

	// Command to use impala-shell for Unified Analytics with Kerberos authentication in Private Cloud.
	FengKerberosImpalaShell string `json:"fengKerberosImpalaShell,omitempty"`

	// JDBC URL for Hive Virtual Warehouses.
	HiveJdbc string `json:"hiveJdbc,omitempty"`

	// JDBC URL with Kerberos authentication for Hive Virtual Warehouses in Private Cloud.
	HiveKerberosJdbc string `json:"hiveKerberosJdbc,omitempty"`

	// Hostname for clients to use when connecting to the VW.
	Hostname string `json:"hostname,omitempty"`

	// URL of Hue for both Hive and Impala Virtual Warehouses.
	Hue string `json:"hue,omitempty"`

	// FENG JDBC URL for Impala Virtual Warehouses.
	ImpalaFENGJdbc string `json:"impalaFENGJdbc,omitempty"`

	// Unified Analytics JDBC URL with Kerberos authentication for Impala Virtual Warehouses in Private Cloud.
	ImpalaFengKerberosJdbc string `json:"impalaFengKerberosJdbc,omitempty"`

	// JDBC URL for Impala Virtual Warehouses.
	ImpalaJdbc string `json:"impalaJdbc,omitempty"`

	// JDBC URL for Impala Virtual Warehouses with Kerberos authentication.
	ImpalaKerberosJdbc string `json:"impalaKerberosJdbc,omitempty"`

	// Command to use impala-shell for Impala Virtual Warehouses.
	ImpalaShell string `json:"impalaShell,omitempty"`

	// Generic semi-colon delimited list of key-value pairs that contain all necessary information for clients to construct a connection to this Virtual Warehouse using JWTs as the authentication method.
	JwtConnectionString string `json:"jwtConnectionString,omitempty"`

	// When platform JWT authentication is enabled, contains a URL where a JWT token can be generated by the CDP JWT token provider.
	JwtTokenGenURL string `json:"jwtTokenGenUrl,omitempty"`

	// Command to use impala-shell for Impala Virtual Warehouses with Kerberos authentication.
	KerberosImpalaShell string `json:"kerberosImpalaShell,omitempty"`

	// Port for clients to use when connecting to the VW.
	Port int32 `json:"port,omitempty"`
}

// Validate validates this vw summary endpoints
func (m *VwSummaryEndpoints) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this vw summary endpoints based on context it is used
func (m *VwSummaryEndpoints) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *VwSummaryEndpoints) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VwSummaryEndpoints) UnmarshalBinary(b []byte) error {
	var res VwSummaryEndpoints
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VwSummaryJwtAuth Details related to JWT Authentication settings on this Virtual Warehouse.
//
// swagger:model VwSummaryJwtAuth
type VwSummaryJwtAuth struct {

	// If JWT auth is enabled on the Virtual Warehouse, describes the type of provider.  If set to "CDP", then the CDP JWT auth provider is configured.  If set to "CUSTOM", then another JWT provider is configured.  If empty or missing, then JWT auth is not enabled on this Virtual Warehouse.
	Provider string `json:"provider,omitempty"`
}

// Validate validates this vw summary jwt auth
func (m *VwSummaryJwtAuth) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this vw summary jwt auth based on context it is used
func (m *VwSummaryJwtAuth) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *VwSummaryJwtAuth) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VwSummaryJwtAuth) UnmarshalBinary(b []byte) error {
	var res VwSummaryJwtAuth
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VwSummarySupportedAuthMethods Describes which authentication methods are supported on this Virtual Warehouse.
//
// swagger:model VwSummarySupportedAuthMethods
type VwSummarySupportedAuthMethods struct {

	// Indicates if JWT auth is supported on this Virtual Warehouse.
	// Required: true
	Jwt *bool `json:"jwt"`

	// Indicates if username/password access to this Virtual Warehouse is supported.
	// Required: true
	Ldap *bool `json:"ldap"`

	// Indicates if SSO auth is supported on this Virtual Warehouse.
	// Required: true
	Sso *bool `json:"sso"`
}

// Validate validates this vw summary supported auth methods
func (m *VwSummarySupportedAuthMethods) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateJwt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLdap(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSso(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VwSummarySupportedAuthMethods) validateJwt(formats strfmt.Registry) error {

	if err := validate.Required("supportedAuthMethods"+"."+"jwt", "body", m.Jwt); err != nil {
		return err
	}

	return nil
}

func (m *VwSummarySupportedAuthMethods) validateLdap(formats strfmt.Registry) error {

	if err := validate.Required("supportedAuthMethods"+"."+"ldap", "body", m.Ldap); err != nil {
		return err
	}

	return nil
}

func (m *VwSummarySupportedAuthMethods) validateSso(formats strfmt.Registry) error {

	if err := validate.Required("supportedAuthMethods"+"."+"sso", "body", m.Sso); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this vw summary supported auth methods based on context it is used
func (m *VwSummarySupportedAuthMethods) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *VwSummarySupportedAuthMethods) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VwSummarySupportedAuthMethods) UnmarshalBinary(b []byte) error {
	var res VwSummarySupportedAuthMethods
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
