// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// VwSummary A Virtual Warehouse.
//
// swagger:model VwSummary
type VwSummary struct {

	// The current settings stored for autoscaling.
	AutoscalingOptions *AutoscalingOptionsResponse `json:"autoscalingOptions,omitempty"`

	// Availability zone in which the Virtual Warehouse is running.
	AvailabilityZone string `json:"availabilityZone,omitempty"`

	// CDH image version.
	CdhVersion string `json:"cdhVersion,omitempty"`

	// Denotes whether the Hive Virtual Warehouse is a compactor or not.
	Compactor bool `json:"compactor,omitempty"`

	// ID of the configuration.
	ConfigID string `json:"configId,omitempty"`

	// Creation date of Virtual Warehouse.
	// Format: date-time
	CreationDate strfmt.DateTime `json:"creationDate,omitempty"`

	// The creator of the Virtual Warehouse.
	Creator *ActorResponse `json:"creator,omitempty"`

	// The CRN of the Virtual Warehouse.
	Crn string `json:"crn,omitempty"`

	// ID of Database Catalog that the Virtual Warehouse is attached to.
	DbcID string `json:"dbcId,omitempty"`

	// Denotes whether the Unified Analytics is enabled.
	EnableUnifiedAnalytics bool `json:"enableUnifiedAnalytics,omitempty"`

	// endpoints
	Endpoints *VwSummaryEndpoints `json:"endpoints,omitempty"`

	// The ID of the Virtual Warehouse.
	ID string `json:"id,omitempty"`

	// Current Impala High Availability settings.
	ImpalaHaSettingsOptions *ImpalaHASettingsOptionsResponse `json:"impalaHaSettingsOptions,omitempty"`

	// Current Impala settings.
	ImpalaOptions *ImpalaOptionsResponse `json:"impalaOptions,omitempty"`

	// jwt auth
	JwtAuth *VwSummaryJwtAuth `json:"jwtAuth,omitempty"`

	// The name of the Virtual Warehouse.
	Name string `json:"name,omitempty"`

	// The current settings stored for query-isolation.
	QueryIsolationOptions *QueryIsolationOptionsResponse `json:"queryIsolationOptions,omitempty"`

	// Status information on the current state of replicas in the virtual warehouse.
	ReplicaStatus *ReplicaStatus `json:"replicaStatus,omitempty"`

	// Status of the Virtual Warehouse. Possible values are: Creating, Created, Accepted, Starting, Running, Stopping, Stopped, Updating, PreUpdate, Upgrading, PreUpgrade, Restarting, Deleting, Waiting, Failed, Error.
	Status string `json:"status,omitempty"`

	// Timestamp of the last status change of the Virtual Warehouse.
	// Format: date-time
	StatusChangedAt strfmt.DateTime `json:"statusChangedAt,omitempty"`

	// supported auth methods
	SupportedAuthMethods *VwSummarySupportedAuthMethods `json:"supportedAuthMethods,omitempty"`

	// Tags associated with the resources.
	Tags []*TagResponse `json:"tags"`

	// Denotes whether the Virtual Warehouse has Data Visualisation or not.
	Viz bool `json:"viz,omitempty"`

	// The type of the Virtual Warehouse.
	VwType VwType `json:"vwType,omitempty"`
}

// Validate validates this vw summary
func (m *VwSummary) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAutoscalingOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreationDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEndpoints(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImpalaHaSettingsOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImpalaOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJwtAuth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQueryIsolationOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReplicaStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatusChangedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSupportedAuthMethods(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTags(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVwType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VwSummary) validateAutoscalingOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.AutoscalingOptions) { // not required
		return nil
	}

	if m.AutoscalingOptions != nil {
		if err := m.AutoscalingOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("autoscalingOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("autoscalingOptions")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) validateCreationDate(formats strfmt.Registry) error {
	if swag.IsZero(m.CreationDate) { // not required
		return nil
	}

	if err := validate.FormatOf("creationDate", "body", "date-time", m.CreationDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *VwSummary) validateCreator(formats strfmt.Registry) error {
	if swag.IsZero(m.Creator) { // not required
		return nil
	}

	if m.Creator != nil {
		if err := m.Creator.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("creator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("creator")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) validateEndpoints(formats strfmt.Registry) error {
	if swag.IsZero(m.Endpoints) { // not required
		return nil
	}

	if m.Endpoints != nil {
		if err := m.Endpoints.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("endpoints")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("endpoints")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) validateImpalaHaSettingsOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.ImpalaHaSettingsOptions) { // not required
		return nil
	}

	if m.ImpalaHaSettingsOptions != nil {
		if err := m.ImpalaHaSettingsOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("impalaHaSettingsOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("impalaHaSettingsOptions")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) validateImpalaOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.ImpalaOptions) { // not required
		return nil
	}

	if m.ImpalaOptions != nil {
		if err := m.ImpalaOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("impalaOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("impalaOptions")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) validateJwtAuth(formats strfmt.Registry) error {
	if swag.IsZero(m.JwtAuth) { // not required
		return nil
	}

	if m.JwtAuth != nil {
		if err := m.JwtAuth.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("jwtAuth")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("jwtAuth")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) validateQueryIsolationOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.QueryIsolationOptions) { // not required
		return nil
	}

	if m.QueryIsolationOptions != nil {
		if err := m.QueryIsolationOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("queryIsolationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("queryIsolationOptions")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) validateReplicaStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.ReplicaStatus) { // not required
		return nil
	}

	if m.ReplicaStatus != nil {
		if err := m.ReplicaStatus.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("replicaStatus")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("replicaStatus")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) validateStatusChangedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.StatusChangedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("statusChangedAt", "body", "date-time", m.StatusChangedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *VwSummary) validateSupportedAuthMethods(formats strfmt.Registry) error {
	if swag.IsZero(m.SupportedAuthMethods) { // not required
		return nil
	}

	if m.SupportedAuthMethods != nil {
		if err := m.SupportedAuthMethods.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("supportedAuthMethods")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("supportedAuthMethods")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) validateTags(formats strfmt.Registry) error {
	if swag.IsZero(m.Tags) { // not required
		return nil
	}

	for i := 0; i < len(m.Tags); i++ {
		if swag.IsZero(m.Tags[i]) { // not required
			continue
		}

		if m.Tags[i] != nil {
			if err := m.Tags[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tags" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tags" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VwSummary) validateVwType(formats strfmt.Registry) error {
	if swag.IsZero(m.VwType) { // not required
		return nil
	}

	if err := m.VwType.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("vwType")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("vwType")
		}
		return err
	}

	return nil
}

// ContextValidate validate this vw summary based on the context it is used
func (m *VwSummary) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAutoscalingOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEndpoints(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateImpalaHaSettingsOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateImpalaOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJwtAuth(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQueryIsolationOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReplicaStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSupportedAuthMethods(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTags(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVwType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VwSummary) contextValidateAutoscalingOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.AutoscalingOptions != nil {
		if err := m.AutoscalingOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("autoscalingOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("autoscalingOptions")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) contextValidateCreator(ctx context.Context, formats strfmt.Registry) error {

	if m.Creator != nil {
		if err := m.Creator.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("creator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("creator")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) contextValidateEndpoints(ctx context.Context, formats strfmt.Registry) error {

	if m.Endpoints != nil {
		if err := m.Endpoints.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("endpoints")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("endpoints")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) contextValidateImpalaHaSettingsOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.ImpalaHaSettingsOptions != nil {
		if err := m.ImpalaHaSettingsOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("impalaHaSettingsOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("impalaHaSettingsOptions")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) contextValidateImpalaOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.ImpalaOptions != nil {
		if err := m.ImpalaOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("impalaOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("impalaOptions")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) contextValidateJwtAuth(ctx context.Context, formats strfmt.Registry) error {

	if m.JwtAuth != nil {
		if err := m.JwtAuth.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("jwtAuth")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("jwtAuth")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) contextValidateQueryIsolationOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.QueryIsolationOptions != nil {
		if err := m.QueryIsolationOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("queryIsolationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("queryIsolationOptions")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) contextValidateReplicaStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.ReplicaStatus != nil {
		if err := m.ReplicaStatus.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("replicaStatus")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("replicaStatus")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) contextValidateSupportedAuthMethods(ctx context.Context, formats strfmt.Registry) error {

	if m.SupportedAuthMethods != nil {
		if err := m.SupportedAuthMethods.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("supportedAuthMethods")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("supportedAuthMethods")
			}
			return err
		}
	}

	return nil
}

func (m *VwSummary) contextValidateTags(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Tags); i++ {

		if m.Tags[i] != nil {
			if err := m.Tags[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tags" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tags" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VwSummary) contextValidateVwType(ctx context.Context, formats strfmt.Registry) error {

	if err := m.VwType.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("vwType")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("vwType")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VwSummary) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VwSummary) UnmarshalBinary(b []byte) error {
	var res VwSummary
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VwSummaryEndpoints Endpoints for accessing the Virtual Warehouse.
//
// swagger:model VwSummaryEndpoints
type VwSummaryEndpoints struct {

	// URL of Data Analytics Studio for Hive Virtual Warehouses.
	Das string `json:"das,omitempty"`

	// JDBC URL for Hive Virtual Warehouses.
	HiveJdbc string `json:"hiveJdbc,omitempty"`

	// Hostname for clients to use when connecting to the VW.
	Hostname string `json:"hostname,omitempty"`

	// URL of Hue for both Hive and Impala Virtual Warehouses.
	Hue string `json:"hue,omitempty"`

	// FENG JDBC URL for Impala Virtual Warehouses.
	ImpalaFENGJdbc string `json:"impalaFENGJdbc,omitempty"`

	// JDBC URL for Impala Virtual Warehouses.
	ImpalaJdbc string `json:"impalaJdbc,omitempty"`

	// Command to use impala-shell for Impala Virtual Warehouses.
	ImpalaShell string `json:"impalaShell,omitempty"`

	// Generic semi-colon delimited list of key-value pairs that contain all necessary information for clients to construct a connection to this Virtual Warehouse using JWTs as the authentication method.
	JwtConnectionString string `json:"jwtConnectionString,omitempty"`

	// When platform JWT authentication is enabled, contains a URL where a JWT token can be generated by the CDP JWT token provider.
	JwtTokenGenURL string `json:"jwtTokenGenUrl,omitempty"`

	// Port for clients to use when connecting to the VW.
	Port int32 `json:"port,omitempty"`
}

// Validate validates this vw summary endpoints
func (m *VwSummaryEndpoints) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this vw summary endpoints based on context it is used
func (m *VwSummaryEndpoints) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *VwSummaryEndpoints) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VwSummaryEndpoints) UnmarshalBinary(b []byte) error {
	var res VwSummaryEndpoints
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VwSummaryJwtAuth Details related to JWT Authentication settings on this Virtual Warehouse.
//
// swagger:model VwSummaryJwtAuth
type VwSummaryJwtAuth struct {

	// If JWT auth is enabled on the Virtual Warehouse, describes the type of provider.  If set to "CDP", then the CDP JWT auth provider is configured.  If set to "CUSTOM", then another JWT provider is configured.  If empty or missing, then JWT auth is not enabled on this Virtual Warehouse.
	Provider string `json:"provider,omitempty"`
}

// Validate validates this vw summary jwt auth
func (m *VwSummaryJwtAuth) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this vw summary jwt auth based on context it is used
func (m *VwSummaryJwtAuth) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *VwSummaryJwtAuth) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VwSummaryJwtAuth) UnmarshalBinary(b []byte) error {
	var res VwSummaryJwtAuth
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VwSummarySupportedAuthMethods Describes which authentication methods are supported on this Virtual Warehouse.
//
// swagger:model VwSummarySupportedAuthMethods
type VwSummarySupportedAuthMethods struct {

	// Indicates if JWT auth is supported on this Virtual Warehouse.
	// Required: true
	Jwt *bool `json:"jwt"`

	// Indicates if username/password access to this Virtual Warehouse is supported.
	// Required: true
	Ldap *bool `json:"ldap"`

	// Indicates if SSO auth is supported on this Virtual Warehouse.
	// Required: true
	Sso *bool `json:"sso"`
}

// Validate validates this vw summary supported auth methods
func (m *VwSummarySupportedAuthMethods) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateJwt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLdap(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSso(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VwSummarySupportedAuthMethods) validateJwt(formats strfmt.Registry) error {

	if err := validate.Required("supportedAuthMethods"+"."+"jwt", "body", m.Jwt); err != nil {
		return err
	}

	return nil
}

func (m *VwSummarySupportedAuthMethods) validateLdap(formats strfmt.Registry) error {

	if err := validate.Required("supportedAuthMethods"+"."+"ldap", "body", m.Ldap); err != nil {
		return err
	}

	return nil
}

func (m *VwSummarySupportedAuthMethods) validateSso(formats strfmt.Registry) error {

	if err := validate.Required("supportedAuthMethods"+"."+"sso", "body", m.Sso); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this vw summary supported auth methods based on context it is used
func (m *VwSummarySupportedAuthMethods) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *VwSummarySupportedAuthMethods) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VwSummarySupportedAuthMethods) UnmarshalBinary(b []byte) error {
	var res VwSummarySupportedAuthMethods
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
