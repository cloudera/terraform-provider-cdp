// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	stderrors "errors"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Environment The environment.
//
// swagger:model Environment
type Environment struct {

	// SSH key for accessing cluster node instances.
	Authentication *Authentication `json:"authentication,omitempty"`

	// The Externalized AWS k8s configuration for the environment.
	AwsComputeClusterConfiguration *AWSComputeClusterConfiguration `json:"awsComputeClusterConfiguration,omitempty"`

	// aws details
	AwsDetails *EnvironmentAwsDetails `json:"awsDetails,omitempty"`

	// The Externalized Azure k8s configuration for the environment.
	AzureComputeClusterConfiguration *AzureComputeClusterConfiguration `json:"azureComputeClusterConfiguration,omitempty"`

	// azure details
	AzureDetails *EnvironmentAzureDetails `json:"azureDetails,omitempty"`

	// Storage configuration for backup.
	BackupStorage *BackupStorage `json:"backupStorage,omitempty"`

	// Cloud platform of the environment.
	// Required: true
	CloudPlatform *string `json:"cloudPlatform"`

	// Compute clusters enabled
	ComputeClusterEnabled bool `json:"computeClusterEnabled,omitempty"`

	// Creation date
	// Format: date-time
	Created strfmt.DateTime `json:"created,omitempty"`

	// The CRN of the user who has created the given environment.
	Creator string `json:"creator,omitempty"`

	// Name of the credential of the environment.
	// Required: true
	CredentialName *string `json:"credentialName"`

	// CRN of the environment.
	// Required: true
	Crn *string `json:"crn"`

	// The configured custom docker registry for data services on the environment.
	CustomDockerRegistry *CustomDockerRegistryResponse `json:"customDockerRegistry,omitempty"`

	// Data Services parameters of the environment.
	DataServices *DataServices `json:"dataServices,omitempty"`

	// Description of the environment
	Description string `json:"description,omitempty"`

	// Name of the environment.
	// Required: true
	EnvironmentName *string `json:"environmentName"`

	// Details of FreeIPA instance associated with this environment.
	Freeipa *FreeipaDetails `json:"freeipa,omitempty"`

	// gcp details
	GcpDetails *EnvironmentGcpDetails `json:"gcpDetails,omitempty"`

	// Storage configuration for cluster and audit logs.
	// Required: true
	LogStorage *LogStorage `json:"logStorage"`

	// Network related specifics of the environment.
	// Required: true
	Network *Network `json:"network"`

	// The proxy config.
	ProxyConfig *ProxyConfig `json:"proxyConfig,omitempty"`

	// Region of the environment.
	// Required: true
	Region *string `json:"region"`

	// [Deprecated] When true, this will report additional diagnostic information back to Cloudera.
	ReportDeploymentLogs *bool `json:"reportDeploymentLogs,omitempty"`

	// Security related configurations for Data Hub clusters.
	Security *SecurityResponse `json:"security,omitempty"`

	// Security control for FreeIPA and Data Lake deployment.
	SecurityAccess *SecurityAccess `json:"securityAccess,omitempty"`

	// Status of the environment.
	// Required: true
	Status *string `json:"status"`

	// The status reason.
	StatusReason string `json:"statusReason,omitempty"`

	// Environment tags object containing the tag values defined for the environment.
	Tags *EnvironmentTags `json:"tags,omitempty"`

	// Whether tunneling is enabled for the environment.
	TunnelEnabled bool `json:"tunnelEnabled,omitempty"`

	// CCM version
	TunnelType TunnelType `json:"tunnelType,omitempty"`

	// When this is enabled, diagnostic information about job and query execution is sent to Workload Manager for Data Hub clusters created within this environment.
	WorkloadAnalytics bool `json:"workloadAnalytics,omitempty"`
}

// Validate validates this environment
func (m *Environment) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthentication(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAwsComputeClusterConfiguration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAwsDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAzureComputeClusterConfiguration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAzureDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBackupStorage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCloudPlatform(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCredentialName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCrn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomDockerRegistry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataServices(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnvironmentName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFreeipa(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGcpDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLogStorage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetwork(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProxyConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRegion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecurity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecurityAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTags(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTunnelType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Environment) validateAuthentication(formats strfmt.Registry) error {
	if swag.IsZero(m.Authentication) { // not required
		return nil
	}

	if m.Authentication != nil {
		if err := m.Authentication.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("authentication")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("authentication")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) validateAwsComputeClusterConfiguration(formats strfmt.Registry) error {
	if swag.IsZero(m.AwsComputeClusterConfiguration) { // not required
		return nil
	}

	if m.AwsComputeClusterConfiguration != nil {
		if err := m.AwsComputeClusterConfiguration.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("awsComputeClusterConfiguration")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("awsComputeClusterConfiguration")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) validateAwsDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.AwsDetails) { // not required
		return nil
	}

	if m.AwsDetails != nil {
		if err := m.AwsDetails.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("awsDetails")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("awsDetails")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) validateAzureComputeClusterConfiguration(formats strfmt.Registry) error {
	if swag.IsZero(m.AzureComputeClusterConfiguration) { // not required
		return nil
	}

	if m.AzureComputeClusterConfiguration != nil {
		if err := m.AzureComputeClusterConfiguration.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("azureComputeClusterConfiguration")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("azureComputeClusterConfiguration")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) validateAzureDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.AzureDetails) { // not required
		return nil
	}

	if m.AzureDetails != nil {
		if err := m.AzureDetails.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("azureDetails")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("azureDetails")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) validateBackupStorage(formats strfmt.Registry) error {
	if swag.IsZero(m.BackupStorage) { // not required
		return nil
	}

	if m.BackupStorage != nil {
		if err := m.BackupStorage.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("backupStorage")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("backupStorage")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) validateCloudPlatform(formats strfmt.Registry) error {

	if err := validate.Required("cloudPlatform", "body", m.CloudPlatform); err != nil {
		return err
	}

	return nil
}

func (m *Environment) validateCreated(formats strfmt.Registry) error {
	if swag.IsZero(m.Created) { // not required
		return nil
	}

	if err := validate.FormatOf("created", "body", "date-time", m.Created.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Environment) validateCredentialName(formats strfmt.Registry) error {

	if err := validate.Required("credentialName", "body", m.CredentialName); err != nil {
		return err
	}

	return nil
}

func (m *Environment) validateCrn(formats strfmt.Registry) error {

	if err := validate.Required("crn", "body", m.Crn); err != nil {
		return err
	}

	return nil
}

func (m *Environment) validateCustomDockerRegistry(formats strfmt.Registry) error {
	if swag.IsZero(m.CustomDockerRegistry) { // not required
		return nil
	}

	if m.CustomDockerRegistry != nil {
		if err := m.CustomDockerRegistry.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("customDockerRegistry")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("customDockerRegistry")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) validateDataServices(formats strfmt.Registry) error {
	if swag.IsZero(m.DataServices) { // not required
		return nil
	}

	if m.DataServices != nil {
		if err := m.DataServices.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("dataServices")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("dataServices")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) validateEnvironmentName(formats strfmt.Registry) error {

	if err := validate.Required("environmentName", "body", m.EnvironmentName); err != nil {
		return err
	}

	return nil
}

func (m *Environment) validateFreeipa(formats strfmt.Registry) error {
	if swag.IsZero(m.Freeipa) { // not required
		return nil
	}

	if m.Freeipa != nil {
		if err := m.Freeipa.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("freeipa")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("freeipa")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) validateGcpDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.GcpDetails) { // not required
		return nil
	}

	if m.GcpDetails != nil {
		if err := m.GcpDetails.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("gcpDetails")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("gcpDetails")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) validateLogStorage(formats strfmt.Registry) error {

	if err := validate.Required("logStorage", "body", m.LogStorage); err != nil {
		return err
	}

	if m.LogStorage != nil {
		if err := m.LogStorage.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("logStorage")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("logStorage")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) validateNetwork(formats strfmt.Registry) error {

	if err := validate.Required("network", "body", m.Network); err != nil {
		return err
	}

	if m.Network != nil {
		if err := m.Network.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("network")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("network")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) validateProxyConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.ProxyConfig) { // not required
		return nil
	}

	if m.ProxyConfig != nil {
		if err := m.ProxyConfig.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("proxyConfig")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("proxyConfig")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) validateRegion(formats strfmt.Registry) error {

	if err := validate.Required("region", "body", m.Region); err != nil {
		return err
	}

	return nil
}

func (m *Environment) validateSecurity(formats strfmt.Registry) error {
	if swag.IsZero(m.Security) { // not required
		return nil
	}

	if m.Security != nil {
		if err := m.Security.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("security")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("security")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) validateSecurityAccess(formats strfmt.Registry) error {
	if swag.IsZero(m.SecurityAccess) { // not required
		return nil
	}

	if m.SecurityAccess != nil {
		if err := m.SecurityAccess.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("securityAccess")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("securityAccess")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *Environment) validateTags(formats strfmt.Registry) error {
	if swag.IsZero(m.Tags) { // not required
		return nil
	}

	if m.Tags != nil {
		if err := m.Tags.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("tags")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("tags")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) validateTunnelType(formats strfmt.Registry) error {
	if swag.IsZero(m.TunnelType) { // not required
		return nil
	}

	if err := m.TunnelType.Validate(formats); err != nil {
		ve := new(errors.Validation)
		if stderrors.As(err, &ve) {
			return ve.ValidateName("tunnelType")
		}
		ce := new(errors.CompositeError)
		if stderrors.As(err, &ce) {
			return ce.ValidateName("tunnelType")
		}

		return err
	}

	return nil
}

// ContextValidate validate this environment based on the context it is used
func (m *Environment) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAuthentication(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAwsComputeClusterConfiguration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAwsDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAzureComputeClusterConfiguration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAzureDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBackupStorage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCustomDockerRegistry(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDataServices(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFreeipa(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGcpDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLogStorage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNetwork(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProxyConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSecurity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSecurityAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTags(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTunnelType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Environment) contextValidateAuthentication(ctx context.Context, formats strfmt.Registry) error {

	if m.Authentication != nil {

		if swag.IsZero(m.Authentication) { // not required
			return nil
		}

		if err := m.Authentication.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("authentication")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("authentication")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) contextValidateAwsComputeClusterConfiguration(ctx context.Context, formats strfmt.Registry) error {

	if m.AwsComputeClusterConfiguration != nil {

		if swag.IsZero(m.AwsComputeClusterConfiguration) { // not required
			return nil
		}

		if err := m.AwsComputeClusterConfiguration.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("awsComputeClusterConfiguration")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("awsComputeClusterConfiguration")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) contextValidateAwsDetails(ctx context.Context, formats strfmt.Registry) error {

	if m.AwsDetails != nil {

		if swag.IsZero(m.AwsDetails) { // not required
			return nil
		}

		if err := m.AwsDetails.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("awsDetails")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("awsDetails")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) contextValidateAzureComputeClusterConfiguration(ctx context.Context, formats strfmt.Registry) error {

	if m.AzureComputeClusterConfiguration != nil {

		if swag.IsZero(m.AzureComputeClusterConfiguration) { // not required
			return nil
		}

		if err := m.AzureComputeClusterConfiguration.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("azureComputeClusterConfiguration")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("azureComputeClusterConfiguration")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) contextValidateAzureDetails(ctx context.Context, formats strfmt.Registry) error {

	if m.AzureDetails != nil {

		if swag.IsZero(m.AzureDetails) { // not required
			return nil
		}

		if err := m.AzureDetails.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("azureDetails")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("azureDetails")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) contextValidateBackupStorage(ctx context.Context, formats strfmt.Registry) error {

	if m.BackupStorage != nil {

		if swag.IsZero(m.BackupStorage) { // not required
			return nil
		}

		if err := m.BackupStorage.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("backupStorage")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("backupStorage")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) contextValidateCustomDockerRegistry(ctx context.Context, formats strfmt.Registry) error {

	if m.CustomDockerRegistry != nil {

		if swag.IsZero(m.CustomDockerRegistry) { // not required
			return nil
		}

		if err := m.CustomDockerRegistry.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("customDockerRegistry")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("customDockerRegistry")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) contextValidateDataServices(ctx context.Context, formats strfmt.Registry) error {

	if m.DataServices != nil {

		if swag.IsZero(m.DataServices) { // not required
			return nil
		}

		if err := m.DataServices.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("dataServices")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("dataServices")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) contextValidateFreeipa(ctx context.Context, formats strfmt.Registry) error {

	if m.Freeipa != nil {

		if swag.IsZero(m.Freeipa) { // not required
			return nil
		}

		if err := m.Freeipa.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("freeipa")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("freeipa")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) contextValidateGcpDetails(ctx context.Context, formats strfmt.Registry) error {

	if m.GcpDetails != nil {

		if swag.IsZero(m.GcpDetails) { // not required
			return nil
		}

		if err := m.GcpDetails.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("gcpDetails")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("gcpDetails")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) contextValidateLogStorage(ctx context.Context, formats strfmt.Registry) error {

	if m.LogStorage != nil {

		if err := m.LogStorage.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("logStorage")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("logStorage")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) contextValidateNetwork(ctx context.Context, formats strfmt.Registry) error {

	if m.Network != nil {

		if err := m.Network.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("network")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("network")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) contextValidateProxyConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.ProxyConfig != nil {

		if swag.IsZero(m.ProxyConfig) { // not required
			return nil
		}

		if err := m.ProxyConfig.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("proxyConfig")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("proxyConfig")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) contextValidateSecurity(ctx context.Context, formats strfmt.Registry) error {

	if m.Security != nil {

		if swag.IsZero(m.Security) { // not required
			return nil
		}

		if err := m.Security.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("security")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("security")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) contextValidateSecurityAccess(ctx context.Context, formats strfmt.Registry) error {

	if m.SecurityAccess != nil {

		if swag.IsZero(m.SecurityAccess) { // not required
			return nil
		}

		if err := m.SecurityAccess.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("securityAccess")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("securityAccess")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) contextValidateTags(ctx context.Context, formats strfmt.Registry) error {

	if m.Tags != nil {

		if swag.IsZero(m.Tags) { // not required
			return nil
		}

		if err := m.Tags.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("tags")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("tags")
			}

			return err
		}
	}

	return nil
}

func (m *Environment) contextValidateTunnelType(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.TunnelType) { // not required
		return nil
	}

	if err := m.TunnelType.ContextValidate(ctx, formats); err != nil {
		ve := new(errors.Validation)
		if stderrors.As(err, &ve) {
			return ve.ValidateName("tunnelType")
		}
		ce := new(errors.CompositeError)
		if stderrors.As(err, &ce) {
			return ce.ValidateName("tunnelType")
		}

		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Environment) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Environment) UnmarshalBinary(b []byte) error {
	var res Environment
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EnvironmentAwsDetails AWS-specific environment configuration information.
//
// swagger:model EnvironmentAwsDetails
type EnvironmentAwsDetails struct {

	// Deprecated. S3Guard was used to ensure consistent S3 updates when S3 was still eventually consistent. With the introduction of Consistent S3, the goal and usage of S3 Guard have become superfluous and defunct.
	S3GuardTableName string `json:"s3GuardTableName,omitempty"`
}

// Validate validates this environment aws details
func (m *EnvironmentAwsDetails) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this environment aws details based on context it is used
func (m *EnvironmentAwsDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *EnvironmentAwsDetails) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EnvironmentAwsDetails) UnmarshalBinary(b []byte) error {
	var res EnvironmentAwsDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EnvironmentAzureDetails Azure specific environment configuration information.
//
// swagger:model EnvironmentAzureDetails
type EnvironmentAzureDetails struct {

	// Object containing details of encryption parameters for Azure cloud.
	ResourceEncryptionParameters *AzureResourceEncryptionParameters `json:"resourceEncryptionParameters,omitempty"`

	// Name of an existing Azure resource group to be used for the environment. If it is not specified then new resource groups will be generated.
	ResourceGroupName string `json:"resourceGroupName,omitempty"`
}

// Validate validates this environment azure details
func (m *EnvironmentAzureDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateResourceEncryptionParameters(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EnvironmentAzureDetails) validateResourceEncryptionParameters(formats strfmt.Registry) error {
	if swag.IsZero(m.ResourceEncryptionParameters) { // not required
		return nil
	}

	if m.ResourceEncryptionParameters != nil {
		if err := m.ResourceEncryptionParameters.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("azureDetails" + "." + "resourceEncryptionParameters")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("azureDetails" + "." + "resourceEncryptionParameters")
			}

			return err
		}
	}

	return nil
}

// ContextValidate validate this environment azure details based on the context it is used
func (m *EnvironmentAzureDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateResourceEncryptionParameters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EnvironmentAzureDetails) contextValidateResourceEncryptionParameters(ctx context.Context, formats strfmt.Registry) error {

	if m.ResourceEncryptionParameters != nil {

		if swag.IsZero(m.ResourceEncryptionParameters) { // not required
			return nil
		}

		if err := m.ResourceEncryptionParameters.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("azureDetails" + "." + "resourceEncryptionParameters")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("azureDetails" + "." + "resourceEncryptionParameters")
			}

			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EnvironmentAzureDetails) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EnvironmentAzureDetails) UnmarshalBinary(b []byte) error {
	var res EnvironmentAzureDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EnvironmentGcpDetails GCP specific environment configuration information.
//
// swagger:model EnvironmentGcpDetails
type EnvironmentGcpDetails struct {

	// ID of the Google project where the resources are created.
	SharedProjectID string `json:"sharedProjectId,omitempty"`
}

// Validate validates this environment gcp details
func (m *EnvironmentGcpDetails) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this environment gcp details based on context it is used
func (m *EnvironmentGcpDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *EnvironmentGcpDetails) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EnvironmentGcpDetails) UnmarshalBinary(b []byte) error {
	var res EnvironmentGcpDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
