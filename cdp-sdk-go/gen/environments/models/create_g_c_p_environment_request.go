// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	stderrors "errors"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CreateGCPEnvironmentRequest Request object for a create GCP environment request.
//
// swagger:model CreateGCPEnvironmentRequest
type CreateGCPEnvironmentRequest struct {

	// The zones of the environment in the given region. Multi-zone selection is not supported in GCP yet. It accepts only one zone until support is added.
	AvailabilityZones []string `json:"availabilityZones"`

	// Name of the credential to use for the environment.
	// Required: true
	CredentialName *string `json:"credentialName"`

	// Configures the desired custom docker registry for data services.
	CustomDockerRegistry *CustomDockerRegistryRequest `json:"customDockerRegistry,omitempty"`

	// A description of the environment.
	Description string `json:"description,omitempty"`

	// Whether to enable SSH tunneling for the environment.
	EnableTunnel *bool `json:"enableTunnel,omitempty"`

	// Key Resource ID of the customer managed encryption key to encrypt GCP resources.
	EncryptionKey string `json:"encryptionKey,omitempty"`

	// The scheme for the endpoint gateway. PUBLIC creates an external endpoint that can be accessed over the Internet. Defaults to PRIVATE which restricts the traffic to be internal to the VPC.
	// Enum: ["PUBLIC","PRIVATE"]
	EndpointAccessGatewayScheme string `json:"endpointAccessGatewayScheme,omitempty"`

	// The subnets to use for endpoint access gateway.
	EndpointAccessGatewaySubnetIds []string `json:"endpointAccessGatewaySubnetIds"`

	// The name of the environment. Must contain only lowercase letters, numbers and hyphens.
	// Required: true
	EnvironmentName *string `json:"environmentName"`

	// Parameters needed to use an existing VPC and Subnets. For now only existing network params is supported.
	// Required: true
	ExistingNetworkParams *ExistingGCPNetworkRequest `json:"existingNetworkParams"`

	// The FreeIPA creation request for the environment
	FreeIpa *GCPFreeIpaCreationRequest `json:"freeIpa,omitempty"`

	// The FreeIPA image request for the environment.
	Image *FreeIpaImageRequest `json:"image,omitempty"`

	// GCP storage configuration for cluster and audit logs.
	LogStorage *GcpLogStorageRequest `json:"logStorage,omitempty"`

	// Name of the proxy config to use for the environment.
	ProxyConfigName string `json:"proxyConfigName,omitempty"`

	// Public SSH key string. The associated private key can be used to get root-level access to the Data Lake instance and Data Hub cluster instances.
	// Required: true
	PublicKey *string `json:"publicKey"`

	// The region of the environment.
	// Required: true
	Region *string `json:"region"`

	// [Deprecated] When true, this will report additional diagnostic information back to Cloudera.
	ReportDeploymentLogs *bool `json:"reportDeploymentLogs,omitempty"`

	// Security related configurations for Data Hub clusters.
	Security *SecurityRequest `json:"security,omitempty"`

	// Firewall rules for FreeIPA, Data Lake and Data Hub deployment.
	SecurityAccess *GcpSecurityAccessRequest `json:"securityAccess,omitempty"`

	// Tags that can be attached to GCP resources. Please refer to Google documentation for the rules https://cloud.google.com/compute/docs/labeling-resources#label_format.
	Tags []*GcpTagRequest `json:"tags"`

	// Whether to associate public ip's to the resources within the network.
	// Required: true
	UsePublicIP *bool `json:"usePublicIp"`

	// When this is enabled, diagnostic information about job and query execution is sent to Workload Manager for Data Hub clusters created within this environment.
	WorkloadAnalytics bool `json:"workloadAnalytics,omitempty"`
}

// Validate validates this create g c p environment request
func (m *CreateGCPEnvironmentRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCredentialName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomDockerRegistry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEndpointAccessGatewayScheme(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnvironmentName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExistingNetworkParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFreeIpa(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLogStorage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePublicKey(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRegion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecurity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecurityAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTags(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsePublicIP(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CreateGCPEnvironmentRequest) validateCredentialName(formats strfmt.Registry) error {

	if err := validate.Required("credentialName", "body", m.CredentialName); err != nil {
		return err
	}

	return nil
}

func (m *CreateGCPEnvironmentRequest) validateCustomDockerRegistry(formats strfmt.Registry) error {
	if swag.IsZero(m.CustomDockerRegistry) { // not required
		return nil
	}

	if m.CustomDockerRegistry != nil {
		if err := m.CustomDockerRegistry.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("customDockerRegistry")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("customDockerRegistry")
			}

			return err
		}
	}

	return nil
}

var createGCPEnvironmentRequestTypeEndpointAccessGatewaySchemePropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PUBLIC","PRIVATE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createGCPEnvironmentRequestTypeEndpointAccessGatewaySchemePropEnum = append(createGCPEnvironmentRequestTypeEndpointAccessGatewaySchemePropEnum, v)
	}
}

const (

	// CreateGCPEnvironmentRequestEndpointAccessGatewaySchemePUBLIC captures enum value "PUBLIC"
	CreateGCPEnvironmentRequestEndpointAccessGatewaySchemePUBLIC string = "PUBLIC"

	// CreateGCPEnvironmentRequestEndpointAccessGatewaySchemePRIVATE captures enum value "PRIVATE"
	CreateGCPEnvironmentRequestEndpointAccessGatewaySchemePRIVATE string = "PRIVATE"
)

// prop value enum
func (m *CreateGCPEnvironmentRequest) validateEndpointAccessGatewaySchemeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createGCPEnvironmentRequestTypeEndpointAccessGatewaySchemePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CreateGCPEnvironmentRequest) validateEndpointAccessGatewayScheme(formats strfmt.Registry) error {
	if swag.IsZero(m.EndpointAccessGatewayScheme) { // not required
		return nil
	}

	// value enum
	if err := m.validateEndpointAccessGatewaySchemeEnum("endpointAccessGatewayScheme", "body", m.EndpointAccessGatewayScheme); err != nil {
		return err
	}

	return nil
}

func (m *CreateGCPEnvironmentRequest) validateEnvironmentName(formats strfmt.Registry) error {

	if err := validate.Required("environmentName", "body", m.EnvironmentName); err != nil {
		return err
	}

	return nil
}

func (m *CreateGCPEnvironmentRequest) validateExistingNetworkParams(formats strfmt.Registry) error {

	if err := validate.Required("existingNetworkParams", "body", m.ExistingNetworkParams); err != nil {
		return err
	}

	if m.ExistingNetworkParams != nil {
		if err := m.ExistingNetworkParams.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("existingNetworkParams")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("existingNetworkParams")
			}

			return err
		}
	}

	return nil
}

func (m *CreateGCPEnvironmentRequest) validateFreeIpa(formats strfmt.Registry) error {
	if swag.IsZero(m.FreeIpa) { // not required
		return nil
	}

	if m.FreeIpa != nil {
		if err := m.FreeIpa.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("freeIpa")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("freeIpa")
			}

			return err
		}
	}

	return nil
}

func (m *CreateGCPEnvironmentRequest) validateImage(formats strfmt.Registry) error {
	if swag.IsZero(m.Image) { // not required
		return nil
	}

	if m.Image != nil {
		if err := m.Image.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("image")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("image")
			}

			return err
		}
	}

	return nil
}

func (m *CreateGCPEnvironmentRequest) validateLogStorage(formats strfmt.Registry) error {
	if swag.IsZero(m.LogStorage) { // not required
		return nil
	}

	if m.LogStorage != nil {
		if err := m.LogStorage.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("logStorage")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("logStorage")
			}

			return err
		}
	}

	return nil
}

func (m *CreateGCPEnvironmentRequest) validatePublicKey(formats strfmt.Registry) error {

	if err := validate.Required("publicKey", "body", m.PublicKey); err != nil {
		return err
	}

	return nil
}

func (m *CreateGCPEnvironmentRequest) validateRegion(formats strfmt.Registry) error {

	if err := validate.Required("region", "body", m.Region); err != nil {
		return err
	}

	return nil
}

func (m *CreateGCPEnvironmentRequest) validateSecurity(formats strfmt.Registry) error {
	if swag.IsZero(m.Security) { // not required
		return nil
	}

	if m.Security != nil {
		if err := m.Security.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("security")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("security")
			}

			return err
		}
	}

	return nil
}

func (m *CreateGCPEnvironmentRequest) validateSecurityAccess(formats strfmt.Registry) error {
	if swag.IsZero(m.SecurityAccess) { // not required
		return nil
	}

	if m.SecurityAccess != nil {
		if err := m.SecurityAccess.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("securityAccess")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("securityAccess")
			}

			return err
		}
	}

	return nil
}

func (m *CreateGCPEnvironmentRequest) validateTags(formats strfmt.Registry) error {
	if swag.IsZero(m.Tags) { // not required
		return nil
	}

	for i := 0; i < len(m.Tags); i++ {
		if swag.IsZero(m.Tags[i]) { // not required
			continue
		}

		if m.Tags[i] != nil {
			if err := m.Tags[i].Validate(formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("tags" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("tags" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *CreateGCPEnvironmentRequest) validateUsePublicIP(formats strfmt.Registry) error {

	if err := validate.Required("usePublicIp", "body", m.UsePublicIP); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create g c p environment request based on the context it is used
func (m *CreateGCPEnvironmentRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCustomDockerRegistry(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExistingNetworkParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFreeIpa(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateImage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLogStorage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSecurity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSecurityAccess(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTags(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CreateGCPEnvironmentRequest) contextValidateCustomDockerRegistry(ctx context.Context, formats strfmt.Registry) error {

	if m.CustomDockerRegistry != nil {

		if swag.IsZero(m.CustomDockerRegistry) { // not required
			return nil
		}

		if err := m.CustomDockerRegistry.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("customDockerRegistry")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("customDockerRegistry")
			}

			return err
		}
	}

	return nil
}

func (m *CreateGCPEnvironmentRequest) contextValidateExistingNetworkParams(ctx context.Context, formats strfmt.Registry) error {

	if m.ExistingNetworkParams != nil {

		if err := m.ExistingNetworkParams.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("existingNetworkParams")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("existingNetworkParams")
			}

			return err
		}
	}

	return nil
}

func (m *CreateGCPEnvironmentRequest) contextValidateFreeIpa(ctx context.Context, formats strfmt.Registry) error {

	if m.FreeIpa != nil {

		if swag.IsZero(m.FreeIpa) { // not required
			return nil
		}

		if err := m.FreeIpa.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("freeIpa")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("freeIpa")
			}

			return err
		}
	}

	return nil
}

func (m *CreateGCPEnvironmentRequest) contextValidateImage(ctx context.Context, formats strfmt.Registry) error {

	if m.Image != nil {

		if swag.IsZero(m.Image) { // not required
			return nil
		}

		if err := m.Image.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("image")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("image")
			}

			return err
		}
	}

	return nil
}

func (m *CreateGCPEnvironmentRequest) contextValidateLogStorage(ctx context.Context, formats strfmt.Registry) error {

	if m.LogStorage != nil {

		if swag.IsZero(m.LogStorage) { // not required
			return nil
		}

		if err := m.LogStorage.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("logStorage")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("logStorage")
			}

			return err
		}
	}

	return nil
}

func (m *CreateGCPEnvironmentRequest) contextValidateSecurity(ctx context.Context, formats strfmt.Registry) error {

	if m.Security != nil {

		if swag.IsZero(m.Security) { // not required
			return nil
		}

		if err := m.Security.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("security")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("security")
			}

			return err
		}
	}

	return nil
}

func (m *CreateGCPEnvironmentRequest) contextValidateSecurityAccess(ctx context.Context, formats strfmt.Registry) error {

	if m.SecurityAccess != nil {

		if swag.IsZero(m.SecurityAccess) { // not required
			return nil
		}

		if err := m.SecurityAccess.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("securityAccess")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("securityAccess")
			}

			return err
		}
	}

	return nil
}

func (m *CreateGCPEnvironmentRequest) contextValidateTags(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Tags); i++ {

		if m.Tags[i] != nil {

			if swag.IsZero(m.Tags[i]) { // not required
				return nil
			}

			if err := m.Tags[i].ContextValidate(ctx, formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("tags" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("tags" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *CreateGCPEnvironmentRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CreateGCPEnvironmentRequest) UnmarshalBinary(b []byte) error {
	var res CreateGCPEnvironmentRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
