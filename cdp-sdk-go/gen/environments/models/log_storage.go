// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	stderrors "errors"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// LogStorage Storage configuration for cluster and audit logs.
//
// swagger:model LogStorage
type LogStorage struct {

	// aws details
	AwsDetails *LogStorageAwsDetails `json:"awsDetails,omitempty"`

	// azure details
	AzureDetails *LogStorageAzureDetails `json:"azureDetails,omitempty"`

	// Whether external log storage is enabled.
	// Required: true
	Enabled *bool `json:"enabled"`

	// gcp details
	GcpDetails *LogStorageGcpDetails `json:"gcpDetails,omitempty"`
}

// Validate validates this log storage
func (m *LogStorage) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAwsDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAzureDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGcpDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LogStorage) validateAwsDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.AwsDetails) { // not required
		return nil
	}

	if m.AwsDetails != nil {
		if err := m.AwsDetails.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("awsDetails")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("awsDetails")
			}

			return err
		}
	}

	return nil
}

func (m *LogStorage) validateAzureDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.AzureDetails) { // not required
		return nil
	}

	if m.AzureDetails != nil {
		if err := m.AzureDetails.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("azureDetails")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("azureDetails")
			}

			return err
		}
	}

	return nil
}

func (m *LogStorage) validateEnabled(formats strfmt.Registry) error {

	if err := validate.Required("enabled", "body", m.Enabled); err != nil {
		return err
	}

	return nil
}

func (m *LogStorage) validateGcpDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.GcpDetails) { // not required
		return nil
	}

	if m.GcpDetails != nil {
		if err := m.GcpDetails.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("gcpDetails")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("gcpDetails")
			}

			return err
		}
	}

	return nil
}

// ContextValidate validate this log storage based on the context it is used
func (m *LogStorage) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAwsDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAzureDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGcpDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LogStorage) contextValidateAwsDetails(ctx context.Context, formats strfmt.Registry) error {

	if m.AwsDetails != nil {

		if swag.IsZero(m.AwsDetails) { // not required
			return nil
		}

		if err := m.AwsDetails.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("awsDetails")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("awsDetails")
			}

			return err
		}
	}

	return nil
}

func (m *LogStorage) contextValidateAzureDetails(ctx context.Context, formats strfmt.Registry) error {

	if m.AzureDetails != nil {

		if swag.IsZero(m.AzureDetails) { // not required
			return nil
		}

		if err := m.AzureDetails.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("azureDetails")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("azureDetails")
			}

			return err
		}
	}

	return nil
}

func (m *LogStorage) contextValidateGcpDetails(ctx context.Context, formats strfmt.Registry) error {

	if m.GcpDetails != nil {

		if swag.IsZero(m.GcpDetails) { // not required
			return nil
		}

		if err := m.GcpDetails.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("gcpDetails")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("gcpDetails")
			}

			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LogStorage) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LogStorage) UnmarshalBinary(b []byte) error {
	var res LogStorage
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LogStorageAwsDetails AWS-specific log storage configuration information.
//
// swagger:model LogStorageAwsDetails
type LogStorageAwsDetails struct {

	// The AWS instance profile that which contains the necessary permissions to access the S3 storage location.
	InstanceProfile string `json:"instanceProfile,omitempty"`

	// The base location to store logs in S3. This should be an s3a:// url.
	StorageLocationBase string `json:"storageLocationBase,omitempty"`
}

// Validate validates this log storage aws details
func (m *LogStorageAwsDetails) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this log storage aws details based on context it is used
func (m *LogStorageAwsDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *LogStorageAwsDetails) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LogStorageAwsDetails) UnmarshalBinary(b []byte) error {
	var res LogStorageAwsDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LogStorageAzureDetails Azure-specific log storage configuration information.
//
// swagger:model LogStorageAzureDetails
type LogStorageAzureDetails struct {

	// The managed identity associated with the logger. This identity should have Storage Blob Data Contributor role on the given storage account.
	ManagedIdentity string `json:"managedIdentity,omitempty"`

	// The storage location to use. The location has to be in the following format abfs://filesystem@storage-account-name.dfs.core.windows.net.
	StorageLocationBase string `json:"storageLocationBase,omitempty"`
}

// Validate validates this log storage azure details
func (m *LogStorageAzureDetails) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this log storage azure details based on context it is used
func (m *LogStorageAzureDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *LogStorageAzureDetails) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LogStorageAzureDetails) UnmarshalBinary(b []byte) error {
	var res LogStorageAzureDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LogStorageGcpDetails GCP-specific log storage configuration information.
//
// swagger:model LogStorageGcpDetails
type LogStorageGcpDetails struct {

	// Email ID of the service account associated with the logging instances.
	ServiceAccountEmail string `json:"serviceAccountEmail,omitempty"`

	// The storage location to use. This should be a gs:// url.
	StorageLocationBase string `json:"storageLocationBase,omitempty"`
}

// Validate validates this log storage gcp details
func (m *LogStorageGcpDetails) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this log storage gcp details based on context it is used
func (m *LogStorageGcpDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *LogStorageGcpDetails) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LogStorageGcpDetails) UnmarshalBinary(b []byte) error {
	var res LogStorageGcpDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
