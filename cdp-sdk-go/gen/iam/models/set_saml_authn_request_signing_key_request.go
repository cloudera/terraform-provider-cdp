// Code generated by go-swagger; DO NOT EDIT.

package models

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SetSamlAuthnRequestSigningKeyRequest Request object for setting the SAML AuthnRequest signing key and verification certificate.
//
// swagger:model SetSamlAuthnRequestSigningKeyRequest
type SetSamlAuthnRequestSigningKeyRequest struct {

	// The private key used for signing AuthnRequests sent from CDP to the customer's SAML provider. It must be in PEM format. It must be non-empty and valid when 'currentAuthnRequestVerificationCertificate' is set. Omitting it from request will remove this key.
	AuthnRequestSigningKey string `json:"authnRequestSigningKey,omitempty"`

	// The certificate used by SAML provider to verify AuthnRequests sent from CDP. It must be in PEM format. It must be non-empty and valid when 'authnRequestSigningKey' is set. Omitting it from request will remove this certificate.
	CurrentAuthnRequestVerificationCertificate string `json:"currentAuthnRequestVerificationCertificate,omitempty"`

	// The next verification certificate used by the SAML provider to verify AuthnRequests sent from CDP. It must be in PEM format. It is used for rotating verification certificate, and is expected to be empty after certification rotation completes. When both the current and next AuthnRequest certificates are set, both will appear in the CDP SP SAML metadata, indicating the Identity Provider should validate if either of the certificates validates the signature of the AuthnRequest. Both must be valid certificates, not expired. Once the Identity Provider has been updated with the new CDP SP SAML metadata to use both certificates, the signing key can be updated to correspond to the next certificate, the current certificate set to what had been next, and the next certificate cleared. The CDP SP SAML metadata can then be updated in the Identity Provider to use only a single certificate before the previous certificate expires. This allows rotating the signing key without downtime. Omitting it from request will remove this certificate.
	NextAuthnRequestVerificationCertificate string `json:"nextAuthnRequestVerificationCertificate,omitempty"`

	// The name or CRN of the SAML Provider associated with the signing key.
	// Required: true
	SamlProvider *string `json:"samlProvider"`
}

// Validate validates this set saml authn request signing key request
func (m *SetSamlAuthnRequestSigningKeyRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSamlProvider(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SetSamlAuthnRequestSigningKeyRequest) validateSamlProvider(formats strfmt.Registry) error {

	if err := validate.Required("samlProvider", "body", m.SamlProvider); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this set saml authn request signing key request based on context it is used
func (m *SetSamlAuthnRequestSigningKeyRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SetSamlAuthnRequestSigningKeyRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SetSamlAuthnRequestSigningKeyRequest) UnmarshalBinary(b []byte) error {
	var res SetSamlAuthnRequestSigningKeyRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
