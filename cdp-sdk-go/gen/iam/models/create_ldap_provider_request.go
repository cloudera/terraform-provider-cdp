// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CreateLdapProviderRequest Create an LDAP Provider for account.
//
// swagger:model CreateLdapProviderRequest
type CreateLdapProviderRequest struct {

	// Bind DN. For example, uid=myapp,ou=users,dc=example,dc=org. Optional. Required if bind is not anonymous.
	BindDn string `json:"bindDn,omitempty"`

	// The password of the bind user.
	BindPassword string `json:"bindPassword,omitempty"`

	// The LDAP email attribute name, will be used as the user's email. For example, mail.
	EmailMappingAttribute string `json:"emailMappingAttribute,omitempty"`

	// The LDAP attribute used as firstname , will be used as the user's firstname. For example, givenName.
	FirstNameMappingAttribute string `json:"firstNameMappingAttribute,omitempty"`

	// The property of user object to use in {{dn}} interpolation of groupSearchFilter.
	GroupDnProperty string `json:"groupDnProperty,omitempty"`

	// The LDAP group attribute name, will be used as for user's group. For example, cn, name.
	GroupNameMappingAttribute string `json:"groupNameMappingAttribute,omitempty"`

	// The distinguished name indicating the path within the directory information tree to begin user searches from. For example, ou=groups,dc=example,dc=com.
	// Required: true
	GroupSearchBase *string `json:"groupSearchBase"`

	// The search filter to use for finding groups for authorization of authenticated users.
	// Required: true
	GroupSearchFilter *string `json:"groupSearchFilter"`

	// The LDAP sn attribute name, will be used as the user's lastname. For example, sn.
	LastNameMappingAttribute string `json:"lastNameMappingAttribute,omitempty"`

	// The name of LDAP provider to create.
	// Required: true
	LdapProviderName *string `json:"ldapProviderName"`

	// Whether to skip group sync.
	SkipGroupSyncOnLogin bool `json:"skipGroupSyncOnLogin,omitempty"`

	// Whether a start TLS request should be initiated on connecting to ldap.
	StartTLS bool `json:"startTls,omitempty"`

	// If the ldaps:// server uses a self-signed SSL certificate or a certificate issued by a private Certificate Authority (CA), then provide the trusted certificates that can be used to validate the LDAP server certificate.
	TLSCaCertificates []string `json:"tlsCaCertificates"`

	// The URL of the LDAP server. The URL must be prefixed with ldap:// or ldaps://. The URL can optionally specify a custom port, for example ldaps://ldap.example.org:663.
	// Required: true
	URL *string `json:"url"`

	// Property of the LDAP user object to use when binding to verify the password. For example, dn.
	UserBindProperty string `json:"userBindProperty,omitempty"`

	// Part of the directory tree under which to search for users. For example, ou=users,dc=example,dc=org.
	// Required: true
	UserSearchBase *string `json:"userSearchBase"`

	// The search filter to use for finding users. For example, (uid={{username}}).
	// Required: true
	UserSearchFilter *string `json:"userSearchFilter"`

	// The LDAP displayName attribute name, will be used as the user's name. For example, uid, sAMAccountName.
	// Required: true
	UsernameMappingAttribute *string `json:"usernameMappingAttribute"`
}

// Validate validates this create ldap provider request
func (m *CreateLdapProviderRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateGroupSearchBase(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGroupSearchFilter(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLdapProviderName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateURL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserSearchBase(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserSearchFilter(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsernameMappingAttribute(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CreateLdapProviderRequest) validateGroupSearchBase(formats strfmt.Registry) error {

	if err := validate.Required("groupSearchBase", "body", m.GroupSearchBase); err != nil {
		return err
	}

	return nil
}

func (m *CreateLdapProviderRequest) validateGroupSearchFilter(formats strfmt.Registry) error {

	if err := validate.Required("groupSearchFilter", "body", m.GroupSearchFilter); err != nil {
		return err
	}

	return nil
}

func (m *CreateLdapProviderRequest) validateLdapProviderName(formats strfmt.Registry) error {

	if err := validate.Required("ldapProviderName", "body", m.LdapProviderName); err != nil {
		return err
	}

	return nil
}

func (m *CreateLdapProviderRequest) validateURL(formats strfmt.Registry) error {

	if err := validate.Required("url", "body", m.URL); err != nil {
		return err
	}

	return nil
}

func (m *CreateLdapProviderRequest) validateUserSearchBase(formats strfmt.Registry) error {

	if err := validate.Required("userSearchBase", "body", m.UserSearchBase); err != nil {
		return err
	}

	return nil
}

func (m *CreateLdapProviderRequest) validateUserSearchFilter(formats strfmt.Registry) error {

	if err := validate.Required("userSearchFilter", "body", m.UserSearchFilter); err != nil {
		return err
	}

	return nil
}

func (m *CreateLdapProviderRequest) validateUsernameMappingAttribute(formats strfmt.Registry) error {

	if err := validate.Required("usernameMappingAttribute", "body", m.UsernameMappingAttribute); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create ldap provider request based on context it is used
func (m *CreateLdapProviderRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CreateLdapProviderRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CreateLdapProviderRequest) UnmarshalBinary(b []byte) error {
	var res CreateLdapProviderRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
