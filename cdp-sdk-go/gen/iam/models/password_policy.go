// Code generated by go-swagger; DO NOT EDIT.

package models

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PasswordPolicy An object representing password policy options.
//
// swagger:model PasswordPolicy
type PasswordPolicy struct {

	// The maximum lifetime of passwords, in days. If set to '0' passwords never expire. The default is 0.
	// Minimum: 0
	MaxPasswordLifetimeDays *int32 `json:"maxPasswordLifetimeDays,omitempty"`

	// The minimum length of a password. Can be any number between 6 and 256. The default minimum password length is 8.
	// Maximum: 256
	// Minimum: 6
	MinPasswordLength int32 `json:"minPasswordLength,omitempty"`

	// The minimum lifetime of passwords, in days. The password must be used for this duration before it can be changed. If set to '0' the password may be changed any time. The default is 0. The minPasswordLifetimeDays must be greater than maxPasswordLifetimeDays.
	// Minimum: 0
	MinPasswordLifetimeDays *int32 `json:"minPasswordLifetimeDays,omitempty"`

	// Whether passwords must include lower case characters. The default is 'true'.
	MustIncludeLowerCaseCharacters bool `json:"mustIncludeLowerCaseCharacters,omitempty"`

	// Whether passwords must include numbers. The default is 'true'.
	MustIncludeNumbers bool `json:"mustIncludeNumbers,omitempty"`

	// Whether passwords must include symbols. The symbols are '#', '&', '*', '$', '%', '@', '^', '.', '_', and '!'. The default is 'true'.
	MustIncludeSymbols bool `json:"mustIncludeSymbols,omitempty"`

	// Whether passwords must include upper case characters. The default is 'true'.
	MustIncludeUpperCaseCharacters bool `json:"mustIncludeUpperCaseCharacters,omitempty"`

	// The number of previous passwords that should be remembered. The user or machine user is prevented from reusing these passwords. Can be any number between 0 and 20. The default is 0, this value means all previous passwords may be reused.
	// Maximum: 20
	// Minimum: 0
	PasswordHistorySize *int32 `json:"passwordHistorySize,omitempty"`
}

// Validate validates this password policy
func (m *PasswordPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMaxPasswordLifetimeDays(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMinPasswordLength(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMinPasswordLifetimeDays(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePasswordHistorySize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PasswordPolicy) validateMaxPasswordLifetimeDays(formats strfmt.Registry) error {
	if swag.IsZero(m.MaxPasswordLifetimeDays) { // not required
		return nil
	}

	if err := validate.MinimumInt("maxPasswordLifetimeDays", "body", int64(*m.MaxPasswordLifetimeDays), 0, false); err != nil {
		return err
	}

	return nil
}

func (m *PasswordPolicy) validateMinPasswordLength(formats strfmt.Registry) error {
	if swag.IsZero(m.MinPasswordLength) { // not required
		return nil
	}

	if err := validate.MinimumInt("minPasswordLength", "body", int64(m.MinPasswordLength), 6, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("minPasswordLength", "body", int64(m.MinPasswordLength), 256, false); err != nil {
		return err
	}

	return nil
}

func (m *PasswordPolicy) validateMinPasswordLifetimeDays(formats strfmt.Registry) error {
	if swag.IsZero(m.MinPasswordLifetimeDays) { // not required
		return nil
	}

	if err := validate.MinimumInt("minPasswordLifetimeDays", "body", int64(*m.MinPasswordLifetimeDays), 0, false); err != nil {
		return err
	}

	return nil
}

func (m *PasswordPolicy) validatePasswordHistorySize(formats strfmt.Registry) error {
	if swag.IsZero(m.PasswordHistorySize) { // not required
		return nil
	}

	if err := validate.MinimumInt("passwordHistorySize", "body", int64(*m.PasswordHistorySize), 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("passwordHistorySize", "body", int64(*m.PasswordHistorySize), 20, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this password policy based on context it is used
func (m *PasswordPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PasswordPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PasswordPolicy) UnmarshalBinary(b []byte) error {
	var res PasswordPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
