// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// EnableServiceRequest Request object for Enable Service method.
//
// swagger:model EnableServiceRequest
type EnableServiceRequest struct {

	// Initial Instances when the service is enabled for the All Purpose Instance Group.
	AllPurposeInitialInstances int32 `json:"allPurposeInitialInstances,omitempty"`

	// Initial spot Instances when the service is enabled for the All Purpose Instance Group.
	AllPurposeInitialSpotInstances int32 `json:"allPurposeInitialSpotInstances,omitempty"`

	// Instance type of the cluster for CDE Service for the All Purpose Instance Group.
	AllPurposeInstanceType string `json:"allPurposeInstanceType,omitempty"`

	// Maximum Instances for the CDE Service for the All Purpose Instance Group.
	AllPurposeMaximumInstances int32 `json:"allPurposeMaximumInstances,omitempty"`

	// Maximum Spot Instances for the CDE Service for the All Purpose Instance Group.
	AllPurposeMaximumSpotInstances int32 `json:"allPurposeMaximumSpotInstances,omitempty"`

	// Minimum Instances for the CDE Service for the All Purpose Instance Group.
	AllPurposeMinimumInstances int32 `json:"allPurposeMinimumInstances,omitempty"`

	// Minimum Spot instances for the CDE Service for the All Purpose Instance Group.
	AllPurposeMinimumSpotInstances int32 `json:"allPurposeMinimumSpotInstances,omitempty"`

	// EBS volume size in GB for the All Purpose Instance Group.
	AllPurposeRootVolumeSize int32 `json:"allPurposeRootVolumeSize,omitempty"`

	// Resource ID of the custom private DNS zone associated with the Azure database.
	AzureDatabasePrivateDNSZoneID string `json:"azureDatabasePrivateDNSZoneId,omitempty"`

	// Resource ID of custom private DNS zone for Azure storage account.
	AzureFilesharePrivateDNSZoneID string `json:"azureFilesharePrivateDNSZoneId,omitempty"`

	// Chart overrides for enabling a service.
	ChartValueOverrides []*ChartValueOverridesRequest `json:"chartValueOverrides"`

	// CPU Requests for the entire CDE service quota.
	CPURequests string `json:"cpuRequests,omitempty"`

	// CDE uses a default public File Shares storage provisioned by AKS. Enable this option to use your own public/private File Shares.
	CustomAzureFilesConfigs *CustomAzureFilesConfigs `json:"customAzureFilesConfigs,omitempty"`

	// If set to "true", the previous version of the CDE service will be deployed.
	DeployPreviousVersion *bool `json:"deployPreviousVersion,omitempty"`

	// Create a fully private CDE instance on either Amazon or Azure. This includes services such as Kubernetes, MySQL, etc. For Azure, this will also enable virtual network (VNet) access via private endpoints and private link.
	EnablePrivateNetwork bool `json:"enablePrivateNetwork,omitempty"`

	// Creates a CDE endpoint (Load Balancer) in a publicly accessible subnet. If set false, the endpoint will be created in a private subnet and you will need to setup access to the endpoint manually in your cloud account.
	EnablePublicEndpoint *bool `json:"enablePublicEndpoint,omitempty"`

	// If set false, diagnostic information about job and query execution is sent to Cloudera Workload Manager. Anonymization can be configured under Environments / Shared Resources / Telemetry. Refer documentation for more info at https://docs.cloudera.com/workload-manager/cloud/index.html.
	EnableWorkloadAnalytics *bool `json:"enableWorkloadAnalytics,omitempty"`

	// CDP environment where cde service should be enabled.
	// Required: true
	Env *string `json:"env"`

	// GPU requests for the entire CDE service quota.
	GpuRequests string `json:"gpuRequests,omitempty"`

	// Initial Instances when the service is enabled.
	InitialInstances int32 `json:"initialInstances,omitempty"`

	// Initial spot Instances when the service is enabled.
	InitialSpotInstances int32 `json:"initialSpotInstances,omitempty"`

	// Instance type of the cluster for CDE Service.
	// Required: true
	InstanceType *string `json:"instanceType"`

	// List of CIDRs that would be allowed to access the load balancer.
	LoadbalancerAllowlist []string `json:"loadbalancerAllowlist"`

	// Maximum Instances for the CDE Service.
	// Required: true
	MaximumInstances *int32 `json:"maximumInstances"`

	// Maximum Spot Instances for the CDE Service.
	MaximumSpotInstances int32 `json:"maximumSpotInstances,omitempty"`

	// Memory requests for the entire CDE service quota, eg. 100Gi.
	MemoryRequests string `json:"memoryRequests,omitempty"`

	// Minimum Instances for the CDE Service.
	// Required: true
	MinimumInstances *int32 `json:"minimumInstances"`

	// Minimum Spot instances for the CDE Service.
	MinimumSpotInstances int32 `json:"minimumSpotInstances,omitempty"`

	// Name of the CDE Service.
	// Required: true
	Name *string `json:"name"`

	// Network outbound type. Currently 'udr' is the only supported.
	// Enum: ["UDR"]
	NetworkOutboundType string `json:"networkOutboundType,omitempty"`

	// NFS Storage class to override the default storage class in private cloud.
	NfsStorageClass string `json:"nfsStorageClass,omitempty"`

	// Resource Pool for the CDE service.
	ResourcePool string `json:"resourcePool,omitempty"`

	// EBS volume size in GB.
	RootVolumeSize int32 `json:"rootVolumeSize,omitempty"`

	// Skip Validation check.
	SkipValidation *bool `json:"skipValidation,omitempty"`

	// List of Subnet IDs of CDP subnets to use for the kubernetes worker node.
	Subnets []string `json:"subnets"`

	// User defined labels that tag all provisioned cloud resources.
	Tags map[string]string `json:"tags,omitempty"`

	// Instance local storage (SSD) would be used for the workload filesystem (Example - spark local directory). In case the workload requires more space than what's available in the instance storage, please use an instance type with sufficient instance local storage or choose an instance type without SSD and configure the EBS volume size. Currently supported only for aws services.
	UseSsd bool `json:"useSsd,omitempty"`

	// List of CIDRs that would be allowed to access kubernetes master API server.
	WhitelistIps []string `json:"whitelistIps"`
}

// Validate validates this enable service request
func (m *EnableServiceRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateChartValueOverrides(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomAzureFilesConfigs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnv(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstanceType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaximumInstances(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMinimumInstances(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkOutboundType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EnableServiceRequest) validateChartValueOverrides(formats strfmt.Registry) error {
	if swag.IsZero(m.ChartValueOverrides) { // not required
		return nil
	}

	for i := 0; i < len(m.ChartValueOverrides); i++ {
		if swag.IsZero(m.ChartValueOverrides[i]) { // not required
			continue
		}

		if m.ChartValueOverrides[i] != nil {
			if err := m.ChartValueOverrides[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("chartValueOverrides" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("chartValueOverrides" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EnableServiceRequest) validateCustomAzureFilesConfigs(formats strfmt.Registry) error {
	if swag.IsZero(m.CustomAzureFilesConfigs) { // not required
		return nil
	}

	if m.CustomAzureFilesConfigs != nil {
		if err := m.CustomAzureFilesConfigs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("customAzureFilesConfigs")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("customAzureFilesConfigs")
			}
			return err
		}
	}

	return nil
}

func (m *EnableServiceRequest) validateEnv(formats strfmt.Registry) error {

	if err := validate.Required("env", "body", m.Env); err != nil {
		return err
	}

	return nil
}

func (m *EnableServiceRequest) validateInstanceType(formats strfmt.Registry) error {

	if err := validate.Required("instanceType", "body", m.InstanceType); err != nil {
		return err
	}

	return nil
}

func (m *EnableServiceRequest) validateMaximumInstances(formats strfmt.Registry) error {

	if err := validate.Required("maximumInstances", "body", m.MaximumInstances); err != nil {
		return err
	}

	return nil
}

func (m *EnableServiceRequest) validateMinimumInstances(formats strfmt.Registry) error {

	if err := validate.Required("minimumInstances", "body", m.MinimumInstances); err != nil {
		return err
	}

	return nil
}

func (m *EnableServiceRequest) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

var enableServiceRequestTypeNetworkOutboundTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["UDR"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		enableServiceRequestTypeNetworkOutboundTypePropEnum = append(enableServiceRequestTypeNetworkOutboundTypePropEnum, v)
	}
}

const (

	// EnableServiceRequestNetworkOutboundTypeUDR captures enum value "UDR"
	EnableServiceRequestNetworkOutboundTypeUDR string = "UDR"
)

// prop value enum
func (m *EnableServiceRequest) validateNetworkOutboundTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, enableServiceRequestTypeNetworkOutboundTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *EnableServiceRequest) validateNetworkOutboundType(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkOutboundType) { // not required
		return nil
	}

	// value enum
	if err := m.validateNetworkOutboundTypeEnum("networkOutboundType", "body", m.NetworkOutboundType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this enable service request based on the context it is used
func (m *EnableServiceRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateChartValueOverrides(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCustomAzureFilesConfigs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EnableServiceRequest) contextValidateChartValueOverrides(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ChartValueOverrides); i++ {

		if m.ChartValueOverrides[i] != nil {

			if swag.IsZero(m.ChartValueOverrides[i]) { // not required
				return nil
			}

			if err := m.ChartValueOverrides[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("chartValueOverrides" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("chartValueOverrides" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EnableServiceRequest) contextValidateCustomAzureFilesConfigs(ctx context.Context, formats strfmt.Registry) error {

	if m.CustomAzureFilesConfigs != nil {

		if swag.IsZero(m.CustomAzureFilesConfigs) { // not required
			return nil
		}

		if err := m.CustomAzureFilesConfigs.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("customAzureFilesConfigs")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("customAzureFilesConfigs")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EnableServiceRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EnableServiceRequest) UnmarshalBinary(b []byte) error {
	var res EnableServiceRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
